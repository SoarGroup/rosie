sp {topstate*elaborate*game-state-input
   (state <s> ^superstate nil
              ^world.predicates <ps>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects <obsj> ^relationships.prep <rels>)# ^turn <n>)
   (<rels> ^name <name>)
-->
   (<ps> ^predicate <p>)
   (<p> ^handle <name>)
}
sp {topstate*elaborate*game-state-input*predicate*instance
   (state <s> ^superstate nil
              ^world.predicates <ps>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects <objs> ^relationships.prep <rels>)# ^turn <n>)
   (<objs> ^object <o1> <o2>)
   (<rels> ^name <name> ^pair <pa>)
   (<ps> ^predicate <p>)
   (<p> ^handle <name>)
   (<o1> ^id <id1>)
   (<o2> ^id <id2>)
   (<pa> ^|1| <id1> ^|2| <id2>)
-->
    (<p> ^instance <i>)
    (<i> ^1 <o1> ^2 <o2>)
}
sp {topstate*elaborate*game-state-input*object
   (state <s> ^superstate nil
              ^world.objects <objs>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects.object <obj> ^relationships <rels>)# ^turn <n>)
-->
   (<objs> ^object <obj>)
   (<obj> ^category block ^primitive object)
}
sp {satisfy-predicate-conditions*propose*predicate-operator*goal
    (state <s1> ^gtype { << goal >> <c2> } 
		   		^completed-learning true 
				^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1>)
    (<p1> ^set <i1>)
-->
    (<s1> ^operator <o1> + > =)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}
sp {satisfy-predicate-conditions*propose*predicate-operator*failure
    (state <s1> ^gtype { << failure >> <c2> } 
		   		^completed-learning true 
				^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1>)
    (<p1> ^set <i1>)
-->
    (<s1> ^operator <o1> + > =)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}
sp {satisfy-predicate-conditions*propose*predicate-operator*action*heuristic
    (state <s1> ^gtype { << action >> <c2> } 
		   		^completed-learning true 
				^list <l1> ^<c2> <a1> ^main-type heuristic)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -{(<s1> ^heuristic.condition <con>)
      (<con> -^result.set.instance)}
-->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs>)
}
sp {satisfy-predicate-conditions*propose*predicate-operator*action
    (state <s1> ^gtype { << action >> <c2> }
		   		^completed-learning true 
		   		^list <l1> ^<c2> <a1> -^main-type heuristic -^main-type predicate)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
-->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs>)
}

sp {satisfy-predicate-conditions*propose*finished-learning-predicate
    (state <s1> ^main-type predicate 
                ^gtype predicate 
                ^list <l1> 
				^completed-learning true 
                ^predicate <a1>
                ^top-state.dialog-context <dc>)
    (<dc> ^learn-link.handle <c1> ^learning true)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
-->
  #  (interrupt)
    (<s1> ^operator <o1> + =)
    (<o1> ^name finished-learning-predicate)
}
sp {satisfy-predicate-conditions*elaborate-finished-learning*predicate
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << predicate >>} ^operator <o>)# ^<type> <a1>)
    (<o> ^name finished-learning-predicate) 
-->
    (<ss> ^finished-learning <type>)
}
sp {satisfy-predicate-conditions*elaborate-finished-learning
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << action >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<p1> ^set <i1>)
-->
    (<ss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*heuristic
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << heuristic >>} ^operator <o> ^<type> <a1>)
    (<o> ^type action -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<p1> ^set <i1>)
-->
    (<ss> ^finished-learning <type>)
}
sp {resolve-conditions*apply*resolve-ungroundable*learning-vis
   (state <s> ^name resolve-conditions
              ^linkstate <ls>
              ^quiescence t
              ^operator <o>
             -^top-state.agent-params.prevent-output-link true
              ^top-state.io.output-link <ol>)
   (<o> ^name resolve-ungroundable)
   (<ls> ^completed-learning true ^<type> <t> ^main-type <type>) #TODO or gtype? should we learn subconcepts?
   (<t> -^final-version true ^parameter-set <p1> ^handle <c1> ^nlp-set <nps>)
-->
    (<ol> ^learning-vis <lv>)
    (<lv> ^solutions (deep-copy <p1>) 
          ^structure (deep-copy <nps>))
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*predicate*learning-vis
    (state <s1> ^top-state.dialog-context.learning true 
                ^superstate <ss>
               -^top-state.agent-params.prevent-output-link true
                ^top-state.io.output-link <ol>)
    (<s1> ^main-type {<type> << predicate >>} ^operator <o> ^<type> <a1>)
    (<o> ^name finished-learning-predicate) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true ^nlp-set <nps>)
-->
    (<ol> ^learning-vis <lv>)
    (<lv> ^solutions (deep-copy <p1>) 
           ^structure (deep-copy <nps>))
}
### todo here: 
sp {satisfy-predicate-conditions*elaborate-finished-learning*learning-vis
    (state <s1> ^top-state.dialog-context.learning true 
                ^superstate <ss>
               -^top-state.agent-params.prevent-output-link true
               -^top-state.dialog-context.number-answer
               -^top-state.dialog-context.needs-new-state
                ^top-state.io.output-link <ol>)
    (<s1> ^main-type {<type> << action goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of -^name format-conditions)
    (<a1> ^parameter-set <p1> ^handle <c1> ^nlp-set <nps> ^final-version true)
-->
    (<ol> ^learning-vis <lv>)
    (<lv> ^solutions (deep-copy <p1>) 
           ^structure (deep-copy <nps>))
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*learning-vis*new-state
    (state <s1> ^top-state.dialog-context.learning true 
                ^superstate <ss>
               -^top-state.agent-params.prevent-output-link true
               -^top-state.dialog-context.number-answer
                ^top-state.dialog-context.needs-new-state
                ^top-state.io.output-link <ol>)
    (<s1> ^main-type {<type> << action goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of -^name format-conditions)
    (<a1> ^parameter-set <p1> ^handle <c1> ^nlp-set <nps>)# ^final-version true)
-->
    (<ol> ^learning-vis <lv>)
    (<lv> ^solutions (deep-copy <p1>) 
           ^structure (deep-copy <nps>))
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*transfer-action-goal-name
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << action >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    (<ss> ^name transfer-action-goal ^superstate.superstate <sss>)
-->
    (<sss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*goal
    (state <s1> ^top-state.dialog-context.learning true ^superstate.superstate <sss> ^superstate <ss>)
    (<s1> ^main-type {<type> << goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^parameters <i1> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<p1> ^set <i1>)
    (<sss> ^superstate <sup>)
-->
    (<sup> ^finished-learning <type>)
    (<sss> ^finished-learning <type>)
    (<ss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*apply*final-version*store*finished-predicate
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true)
    (<s1> ^main-type predicate
          ^operator <o>
          ^predicate <a1>)
    #(<o> ^type <type> -^duplicate-of) 
    (<o> ^name finished-learning-predicate)
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    #(<a1> ^condition <co>)
    #(<co> ^name <n1> ^type concept ^attribute predicate)
    (<dc> ^learning-predicate <lp>)
    (<lp> ^spelling <spell> ^name <c1>)
-->
   (<dc> ^<spell> <c1>)
}


sp {satisfy-predicate-conditions*apply*final-version*store
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true)
    (<s1> ^main-type {<type> << action goal failure >>}
          ^operator <o>
          ^version-list.version <v>
          ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<a1> ^condition <co>)
    (<co> ^name <n1> ^type concept ^attribute predicate)
    (<v> ^handle-spelling <spell> ^item <i>)
    (<i> -^auto ^smem-result.handle <n1>)
-->
   (<dc> ^<spell> <n1>)
}
#zxc
sp {satisfy-predicate-conditions*apply*final-version*store*heuristic
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true)
    (<s1> ^main-type {<type> << heuristic >>}
          ^operator <o>
          ^version-list.version <v>
          ^<type> <a1>)
    (<o> ^type action -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<a1> ^condition <co>)
    (<co> ^name <n1> ^type concept ^attribute predicate)
    (<v> ^handle-spelling <spell> ^item <i>)
    (<i> -^auto ^smem-result.handle <n1>)
-->
   (<dc> ^<spell> <n1>)
}
sp {satisfy-predicate-conditions*apply*final-version*store*antonym
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true ^antonyms <an>)
    (<s1> ^main-type {<type> << action goal failure >>}
          ^operator <o>
          ^version-list.version <v>
          ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<a1> ^condition <co>)
    (<co> ^name <n1> ^type concept ^attribute predicate ^negative true)
    (<v> ^handle-spelling <spell> ^item <i>)
    (<i> ^auto antonym ^smem-result.handle <n1>)
-->
   (<an> ^<spell> <n1>)
}
sp {satisfy-predicate-conditions*apply*final-version*store*synonym
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true ^synonyms <an>)
    (<s1> ^main-type {<type> << action goal failure >>}
          ^operator <o>
          ^version-list.version <v>
          ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^final-version true)
    (<a1> ^condition <co>)
    (<co> ^name <n1> ^type concept ^attribute predicate)
    (<v> ^handle-spelling <spell> ^item <i>)
    (<i> ^auto synonym ^smem-result.handle <n1>)
-->
   (<an> ^<spell> <n1>)
}

#fix heuristics

#simplest case, only version with results, HACK simple for now
sp {satisfy-predicate-conditions*elaborate-finished-learning*final-version
    (state <s1> ^top-state.dialog-context.learning true)
    (<s1> ^main-type {<type> << action goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)# -^final-version)
-{(state <s1>)
  (<p1> -^set <i1>)}
-{(<s1> ^<type> {<a2> <> <a1>}) #doesnt have a second viable version
  (<a2> ^parameter-set <p2>)
    (<p2> ^set <i2>)}
-->
   (<a1> ^final-version true)
}

#zxc
sp {satisfy-predicate-conditions*elaborate-finished-learning*final-version*heuristic
    (state <s1> ^top-state.dialog-context.learning true)
    (<s1> ^main-type {<type> << heuristic >>} ^operator <o> ^<type> <a1>)
    (<o> ^type action -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)# -^final-version)
-{(state <s1>)
  (<p1> -^set <i1>)}
-{(<s1> ^<type> {<a2> <> <a1>}) #doesnt have a second viable version
  (<a2> ^parameter-set <p2>)
    (<p2> ^set <i2>)}
-->
#(interrupt)
   (<a1> ^final-version true)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*final-version*multiple
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true)
    (<dc> ^number-answer <num>)
    (<s1> ^main-type {<type> << action goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^num-results <num>)# -^final-version)
-{(state <s1>)
  (<p1> -^set <i1>)}
-->
   (<a1> ^final-version true)
  # (<dc> ^number-answer <num> -) #or remove later..yeah..
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*final-version*multiple*predicate
    (state <s1> ^top-state.dialog-context <dc>)
    (<dc> ^learning true)
    (<dc> ^number-answer-predicate <num>)
    (<s1> ^predicate <pp> ^main-type {<type> << action goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
	(<pp> ^link <cp> ^num-results <num>) 
    (<a1> ^parameter-set <p1> ^handle <c1> ^condition <cp> ^num-results <n7>)# -^final-version)
-{(state <s1>)
  (<p1> -^set <i1>)}
-->
   (<a1> ^final-version true)
  # (<dc> ^number-answer-predicate <num> -) #or remove later..yeah..
}

# TODO need deep-copy here? #...
sp {satisfy-predicate-conditions*apply*finished-learning*elab-store-link
    (state <s1> ^top-state.dialog-context.learning true
                ^top-state.dialog-context <dc> 
                ^operator.name finished-learning)
    (<ll> ^predicate-structure)
    (<dc> ^learn-link <ll>)
  -{(<dc> ^learn-link {<l2> > <ll>})}#TODO just do test for most recent?
-->
#(interrupt)
#(write (cmd print <ps> -d 10))
#(write (cmd pref <ll> -w))
    (<s1> ^store-link (deep-copy <ll>))
}
sp {satisfy-predicate-conditions*apply*finished-learning*elaborate*source
    (state <s1> ^top-state.dialog-context <dc>
                ^store-link <ll>
                ^operator.name finished-learning)
    (<dc> ^learning true ^name <name>)
-->
    (<ll> ^from <name>)
}

#sp {satisfy-predicate-conditions*apply*finished-learning*elaborate*ASDF
#    (state <s1> ^top-state.dialog-context <dc>
#                ^name finished-learning)
#   (<dc> ^learning true ^learn-link <ll>)
#   (<ll> ^predicate-structure <ps>)
#-->
#(write (cmd print <ll> -d 6))
#(write (cmd print <s1>))
#(write (cmd pref <ll> argnum -w ))
#(write (cmd pref <ps> conditions -w ))
#(write (cmd print fc))
#}
#qqqqqqqqqqqqqqqq

#HACK TO FIX MIRROR JUSTIFICATTION PROBLEM 
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance2
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance3
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance4
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance5
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2>.args.<n3> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance6
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2>.args.<n3>.args.<n4> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance7
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2>.args.<n3>.args.<n4>.args.<n5> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}
sp {finished-learning*store*predicate*concept
   (state <s> ^name finished-learning    
              ^smem.command <sc>
              ^superstate.store-link <ll>)
-->
    (<s> ^store-link <ll>)
    (<s> ^to-store <ll>)
   (<sc> ^store <ll>)
}
sp {finished-learning*propose*store*primary*rtype
   (state <s> ^operator.name finished-learning
              ^store-link <ll>)
   (<ll> ^predicate-structure.conditions.parameter.<num> <p>)
   (<p> ^param-id 1 ^type <rtype>)
-->
   (<ll> ^primary-rtype <rtype>)
}
sp {finished-learning*propose*store*seconday*rtype
   (state <s> ^operator.name finished-learning
              ^store-link <ll>)
   (<ll> ^predicate-structure.conditions.parameter.<num> <p>)
   (<p> ^param-id 2 ^type <rtype>)
-->
   (<ll> ^secondary-rtype <rtype>)
}
sp {finished-learning*propose*store-next-level
   (state <s> ^name finished-learning
             -^all-stored
              ^store-link <ts>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name store-game-level
        ^to-store <ts>)
}
sp {finished-learning*apply*store-next-level*finished
   (state <s> ^name finished-learning
              ^operator <o>)
   (<o> ^name store-game-level)
   -{(<s> ^to-store.<something> {<t2> <=> <s>})
    -{(<s> ^to-store <t2>)}}
-->
   (<s> ^all-stored true)
}
sp {finished-learning*apply*store-next-level2
   (state <s> ^name finished-learning
              ^operator <o>
              ^to-store <ts>
              ^smem.command <sc>)
   (<o> ^name store-game-level)
   (<ts> ^{<something> <> final <> goal-state <> initial } {<something2> <=> <s>})
-->
   (<s> ^to-store <something2>)
   (<sc> ^store <something2>)
}
sp {finished-learning*propose*complete
   (state <s> ^name finished-learning)
-->
   (<s> ^operator <o> + <)
   (<o> ^name complete)
}
#sp {finished-learning*apply*complete*remove-learn-link
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>)
#    (<dc> ^store-learn-link <ll> ^learn-link {<l2> <> <ll>})
#-->
# #   (<dc> ^store-learn-link <ll> -)
# #  (<dc> ^learn-link <ll>)
# #  (<dc> ^learn-link <l2> -)
#}
sp {satisfy-purpose*finished-learning*apply*complete*remove-learn-link
    (state <s1> ^name interaction
                ^operator <o>
               -^top-state.new-spelling #HACKy
                ^top-state.dialog-context <dc>)
    (<dc> ^learn-link <ll> -^store-learn-link) ###?
    (<ll> ^argnum <a>) #means built
    (<o> ^name performed-event
         -^event.learning-event.type game-name
         -^event.dialog-event.type process-unknown-word
        -^event.dialog-event.type process-sentence)
  -{(<dc> ^learn-link {<l2> > <ll>})}#TODO just do test for most recent?
-->
   (<dc> ^learn-link <ll> -)
}

sp {satisfy-purpose*finished-learning*apply*complete*remove-learn-link*alreadylearned
    (state <s1> ^name interaction
                ^operator <o>
               -^top-state.new-spelling #HACKy
                ^top-state.dialog-context <dc>)
    (<dc> ^learn-link <ll> -^store-learn-link) #???
    (<ll> ^argnum <a> ^final-version true) #means built
    (<o> ^name performed-event
         ^event.learning-event.type game-name)
  -{(<dc> ^learn-link {<l2> > <ll>})}#TODO just do test for most recent?
-->
   (<dc> ^learn-link <ll> -)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-object-list*alreadylearned
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game-name)
    (<top> ^dialog-context.learn-link.final-version 
		   ^dialog-world <w> ^dialog-object-list <list> ^dialog-object-list-saved <dls>)
-->
   (<top> ^dialog-object-list <list> -
          ^dialog-world <w> -
          ^dialog-object-list-saved <dls> -
          ^dialog-object-list nil
          ^dialog-object-list-saved nil
          ^dialog-world <new>)
   (<new> ^objects <objs> ^predicates <preds>)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-object-list
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game)
    (<top> ^dialog-world <w> ^dialog-object-list <list> ^dialog-object-list-saved <dls>)
-->
   (<top> ^dialog-object-list <list> -
          ^dialog-world <w> -
          ^dialog-object-list-saved <dls> -
          ^dialog-object-list nil
          ^dialog-object-list-saved nil
          ^dialog-world <new>)
   (<new> ^objects <objs> ^predicates <preds>)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-contexct*number-answer
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game)
    (<top> ^dialog-context <dc>)
    (<dc> ^number-answer <na>)
-->
    (<dc> ^number-answer <na> -)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-contexct*needs-new-state
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game)
    (<top> ^dialog-context <dc>)
    (<dc> ^needs-new-state <na>)
-->
    (<dc> ^needs-new-state <na> -)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-contexct*number-answer-predicate
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game)
    (<top> ^dialog-context <dc>)
    (<dc> ^number-answer-predicate <na>)
-->
    (<dc> ^number-answer-predicate <na> -)
}

sp {satisfy-purpose*clean*dialog-object-list
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-object-list {<dol> <=> <s1>})
-->
    (<ts> ^dialog-object-list <dol> -)
    (<ts> ^dialog-object-list nil)
}
sp {satisfy-purpose*clean*dialog-object-list-saved
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-object-list-saved {<dol> <=> <s1>})
-->
    (<ts> ^dialog-object-list-saved <dol> -)
    (<ts> ^dialog-object-list-saved nil)
}
sp {satisfy-purpose*clean*dialog-world
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-world.<< objects predicates >> <dw>)
    (<dw> ^<something> <obj>)
-->
    (<dw> ^<something> <obj> -)
}
sp {finished-learning*apply*complete*predicate*create-temp-dummy-action
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^superstate <ss>
                ^store-link <sl>
                ^top-state.dialog-context <dc>)
    (<dc> ^learning-predicate.name <name>)
    (<sl> ^handle <name>)
-->
	(<ss> ^gtype action ^action <a>)
	(<a> ^condition <c>)
	(<c> ^name <name> ^type concept ^attribute predicate)
}  
sp {finished-learning*apply*complete*send-message*predicate
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^store-link <stl>
                ^top-state.dialog-context <dc>)
    (<dc> ^learning-predicate.name <name>)
    (<stl> ^handle <name>)
-->
#(interrupt)
#(write (cmd print <s1> -d 2))
#(write (cmd print <dc> -d 2))
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*heuristic
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^store-link <sl>
                ^top-state.dialog-context <dc>)
    (<dc> ^structure.heuristics <act> -^learning-predicate)
    (<sl> ^handle <name> ^ntype heuristic)
-->
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*action
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^superstate <ss>
                ^top-state.dialog-context <dc>)
    (<dc> ^structure.actions <act> -^learning-predicate)
    (<act> ^action <a>)
    (<a> ^handle <name>)
-->
   (<act> ^action <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
#sp {finished-learning*apply*complete*send-message*heuristic*copied
#    (state <s1> ^name finished-learning
#                ^top-state <ts>
#                ^operator.name complete
#                ^top-state.dialog-context <dc>
#                ^top-state.interaction.status <status>
#                ^top-state.interaction.changes <changes>)
#    (<dc> ^structure.heuristics <act> -^learning-predicate ^learn-link.handle <name>)
#    (<act> -^heuristic <a>)
#    (<ts> ^new-spelling <ns>)
#    #(<a> ^handle <name>)
#-->
##(<ts> ^new-spelling <ns> -)
#   (<act> ^retrieve-handle <name>)
#   (<dc> ^finalize-chunk <name>)
#}

sp {finished-learning*apply*complete*send-message*action*copied
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.actions <act> -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type action)
    (<act> -^action <a>)
    #(<ts> ^new-spelling <ns>) #JK check if depricated
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*failure*copied
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.failures <act> -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type failure)# ^type failure)
    (<act> -^failure <a>)
    #(<ts> ^new-spelling <ns>) #JK check if depricated
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
#JK copy issue fixed til here!!!
sp {finished-learning*apply*complete*send-message*goal*copied
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> -^goal-relationships -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type goal)
    (<act> -^goal <a>)
  #(<ts> ^new-spelling <ns>) #JK check if depricated
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*goal
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> -^goal-relationships -^learning-predicate)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
-->
   (<act> ^goal <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*failure
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.failures <act> -^learning-predicate)
    (<act> ^failure <a>)
    (<a> ^handle <name>)
-->
   (<act> ^failure <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*goal-state*demo
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> ^goal-relationships <gs> ^attend <at>)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
-->
   (<act> ^goal <a> -)
   (<dc> ^attend <at> -)
   (<act> ^retrieve-handle <name>)
   (<changes> ^outgoing-message <msg>)
   (<msg> ^type describe-final-goal-state
          ^complete-message true
          ^fields <f>)
   (<f> ^relationships <gs> ^definitive no)
   (<status> ^performed.learning-event <de>)
   (<de> ^type game
         ^originator agent)
}
#hmmm TODO should be chunking this? especially when considering negatives
#negative learned predicate copies
#for single param (all same return type) need to add single to set and set to single, etc
#should work for 2 param indef or single (clear, etc)
sp {satisfy-predicate-conditions*elaborate*condition-instance*negative
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^args <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <type> ^negative true ^parameter <p1>)
    (<p1> ^num < 2 )
    (<ar1> ^1 <c8>)
    (<c8> ^rtype <type> ^result <r5>)
    (<r5> ^set <r52>)
    (<r52> ^instance <i1>)
    (<i1> ^1 <n4>)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype <type> ^parameter-set.tested calculate6)
    (<n1> ^aname <c2>) 
 -{ (state <s1>)
    (<t1> -^instance)} 
 -{ (<t1> ^instance <i3>)
      (<i3> ^1 <n4> )}
-->
    (<s2> ^instance <i5> +)
    (<i5> ^1 <n4>)
}
#sp {satisfy-predicate-conditions*elaborate*condition-instance*negative*set-single
#    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
#    (<l1> ^game <g1>)
#    (<a1> ^condition <c4>)
#    (<c4> ^args <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^negative true ^parameter <p1>)
##    (<p1> ^num < 2 )
##    (<ar1> ^1 <c8>)
##    (<c8> ^rtype set ^result <r5> ^parameter <pz>)
##    (<pz> ^num > 0)
##    (<r5> ^set <r52>)
##    (<r52> ^instance <i1>)
##    (<i1> ^1 <n4>)
##    (<r1> ^set <s2>)
#    (<t1> ^nlp-set <n1> ^link <c4> )#^primary-rtype <tx> ^parameter-set.tested calculate6)
#    (<n1> ^aname <c2>) 
# #-{(state <s1>)
# #  (<t1> -^instance)} 
# #-{(<t1> ^instance <i3>)
# #     (<i3> ^1 <obj>)
## 	  (<n4> ^<x1> <obj>)}
#-->
##(interrupt)
##(write (cmd print <t1> -d 10))
##    (<s2> ^instance <i5> +)
##    (<i5> ^1 <n4>)
#}
sp {satisfy-predicate-conditions*elaborate*condition-instance*negative*2param
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^args <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <type> ^negative true ^parameter <p1>)
    (<p1> ^num 2)
    (<ar1> ^1 <c8> ^2 <c9>)
    (<c8> ^rtype <type> ^result <r5>)
    (<c9> ^rtype <type> ^result <r7>)
    (<r5> ^set <r52>)
    (<r52> ^instance <i1>)
    (<i1> ^1 <n4>)
    (<r7> ^set <r72>)
    (<r72> ^instance <i7>)
    (<i7> ^1 {<> <n4> <n7>})
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype <type> ^parameter-set.tested calculate6)    
    (<n1> ^aname <c2>)
 -{ (state <s1>)
    (<t1> -^instance)} 
 -{ (<t1> ^instance <i3>)
      (<i3> ^1 <n4> ^2 <n7>)
      #(<c5> ^result <r*2>)
      #(<r*2> ^set <s*4>)
      #(<s*4> ^instance <i*2>)
      #(<i*2> ^1 <objb>)
      }
-->
    (<s2> ^instance <i5> +)
    (<i5> ^1 <n4> ^2 <n7>)
}
#check same primary return type (in future need to deal with different param usage of concepts)
sp {satisfy-predicate-conditions*elaborate*condition-instance
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <rtype> ^negative false ^parameter.num < 2)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1> ^link <c4> ^primary-rtype <rtype>)
    (<n1> ^aname <c2>)
-->
    (<s2> ^instance <i1> +)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*primary*secondary
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^parameter.{2}.type <rtype2> ^rtype <rtype> ^negative false ^parameter.num 2)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1> ^link <c4> ^primary-rtype <rtype> ^secondary-rtype <rtype2>)
    (<n1> ^aname <c2>)
-->
    (<s2> ^instance <i1> +)
}

#TODO analyze should try to learn these rules?????
#when child argument was a parameter and a set
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^args.{1} <arg> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<arg> ^rtype set ^parameter.{1}.param-id <pid> ^result.set <s3>)
    (<s3> ^instance <i5>)
    (<i5> ^1 <set>)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single)#^instance <i1> 
    (<n1> ^aname <c2>)
   -{(state <s1>)
     (<set> -^<something>)}
   -{(<set> ^<object> <obj>) #(<set> ^object <obj>)
    -{(<t1> ^instance <i1>)
      (<i1> ^1 <obj>)}}
   -{(<s3> ^instance {<i8> < <i5>})
    (<i8> ^1 <set>)} #bias only create one per object
-->
    (<s2> ^instance <i1>)
    (<i1> ^1 <set>)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*set-single-set*parameters
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter <para> ^args <args> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype single) # 1
	(<r1> ^set <s2>)
	(<para> ^1 <para1> ^2 <para2>)
    (<para1> ^param-id <pid> ^type single)
    (<para2> ^param-id <pid2> ^type set)
    (<args> ^1 <arg1> ^2 <arg2>)
    (<arg1> ^rtype single)
    (<arg2> ^rtype set ^parameter.{1}.param-id <pid2> ^result.set <s3>)
    (<s3> ^instance <i5>)
    (<i5> ^1 <set>) #JK nlp fix?
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single ^instance <i1> ^secondary-rtype single)
    (<i1> ^1 <obja>)
    (<n1> ^aname <c2>)
    -{(state <s1>)
     (<set> -^<something>)}
   -{(<set> ^<object> <obj>) #(<set> ^object <obj>)
    -{(<t1> ^instance <i2>)
      (<i2> ^1 <obja> ^2 <obj>)}}
   -{(<s3> ^instance {<i8> < <i5>})
    (<i8> ^1 <set>)} #bias only create one per object
-->
    (<s2> ^instance <i3>)
    (<i3> ^1 <obja> ^2 <set>)
}
#causes duplicate results...
#could try bias that take lowest instance with 2 as arg...
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters2
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^parameter.{2}.type single ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num 2)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single ^instance <i1> ^secondary-rtype single)
    (<i1> ^2 <obj>)
    (<n1> ^aname <c2>)
   -{(<t1> ^instance {<is1> < <i1>}) #bias for no duplicate results
     (<is1> ^2 <obj>)}
-->
    (<s2> ^instance <ir>)
    (<ir> ^1 <setn> ^2 <obj>)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters2*copy-objects
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^parameter.{2}.type single ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num 2)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single ^instance <i1> ^secondary-rtype single)
    (<i1> ^1 <obj1> ^2 <obj>)
    (<n1> ^aname <c2>)
    (<s2> ^instance <ir>)
    (<ir> ^1 <setn> ^2 <obj>)
-->
    (<setn> ^<object> <obj1>)
}
#only if one main parameter
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^args.{1}.parameter.num 0 ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single)#^instance <i1> 
    (<n1> ^aname <c2>)
    -{(state <s1>)
     (<t1> -^instance)}
-->
    (<s2> ^instance <i1>)
    (<i1> ^1 <set>)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*copy-objects
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^args.{1}.parameter.num 0 ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<r1> ^set.instance.{1} <set>)
    (<t1> ^nlp-set <n1> ^instance.{1} <obj> ^link <c4> ^primary-rtype single)
    (<n1> ^aname <c2>)
-->
    (<set> ^<object> <obj>)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*copy-objects*negative
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative true ^args.{1} <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2)
	(<ar1> ^parameter.num 0 ^rtype single ^result.set.instance.{1} <obj>)
    (<r1> ^set.instance.{1} <set>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single)
    (<n1> ^aname <c2>)
-{(<t1> ^instance <in1>)
  (<in1> ^1 <obj>)}
-->
    (<set> ^<object> <obj>)
}
#any/generic action
sp {satisfy-predicate-conditions*elaborate*condition-instance*action*any
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^action <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name any ^attribute action)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1>)# ^link <c4>)
   # (<n1> ^aname <c2>)
-->
    (<s2> ^instance <i1> +)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*action #TODO fix no link issue
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^action <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name <c2> ^attribute action)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1>)# ^link <c4>)
    (<n1> ^aname <c2>)
-->
    (<s2> ^instance <i1> +)
}
#Assuming just using the verb-structure and directly moved as arguments
# different once use place instead of move
sp {satisfy-predicate-conditions*action*results
    (state <s> ^<gt> <p> ^action <t> ^list <l1> ^gtype action ^gtype { <gt> << heuristic predicate goal >>})# heuristic)#^ntype heuristic 
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action ^verb <verb> ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-prep <verb> ^verb-name <name>)
    (<r1> ^set <rset>)
-->
    (<rset> ^instance <in> +)
}
sp {satisfy-predicate-conditions*action-predicate*results
    (state <s> ^predicate <p> ^action <t> ^list <l1> ^gtype action)#may cause issues ^main-type predicate)#^ntype heuristic 
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action ^verb <verb> ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-prep <verb> ^verb-name <name>)
    (<r1> ^set <rset>)
-->
    (<rset> ^instance <in> +)
}
sp {satisfy-predicate-conditions*action*results*no-verb
    (state <s> ^heuristic <p> ^action <t> ^list <l1> ^gtype action heuristic)#^ntype heuristic
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action -^verb ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-name <name>) #verb-prep
    (<r1> ^set <rset>)
-->
    (<rset> ^instance <in> +)
}
##TODO may not need this once we have ewave working
sp {satisfy-predicate-conditions*elaborate*calculate6
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate5 ^tested calculate4)
-->
    (<p2> ^tested calculate6 +)
}
sp {satisfy-predicate-conditions*elaborate*calculate5
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate4 ^tested calculate3)
-->
    (<p2> ^tested calculate5 +)
}
sp {satisfy-predicate-conditions*elaborate*calculate4
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate3 ^tested calculate2)
-->
    (<p2> ^tested calculate4 +)
}
#sp {satisfy-predicate-conditions*elaborate*calculate3
#    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
#    (<l1> ^game <g1>)
#    (<a1> ^parameter-set <p2> ^potential-args <p1>)
#    (<p2> ^tested calculate2 ^tested calculate1)
#    -->
#    (<p2> ^tested calculate3 +)
#}
#
sp {satisfy-predicate-conditions*elaborate*calculate2
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate1)
-->
    (<p2> ^tested calculate2 calculate3)
}
#sp {satisfy-predicate-conditions*elaborate*calculate23456
#    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
#    (<l1> ^game <g1>)
#    (<a1> ^parameter-set <p2> ^potential-args <p1>)
#    (<p2> ^tested calculate3)
#    -->
#    (<p2> ^tested calculate4 calculate5 calculate6)
#}
#test that all conditions have an instance with a result
sp {satisfy-predicate-conditions*elaborate*calculate1
    (state <s1> ^simulated true ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2>)
    -{(state <s1>)
      (<p1> -^<asdf>)}
    -{(<a1> ^condition <c>)
      (<c> ^result.set <rset> ^return-type number)
     -{(<rset> ^instance.{1})}}
   -{(<a1> ^condition <c2>)
      (<c2> ^result.set <rset2> -^return-type number)
     -{(<rset2> ^instance.{1}.<elem>)}}
-->
    (<p2> ^tested calculate1 +)
}

sp {satisfy-predicate-conditions*elaborate*instance*from-predicate-results
    (state <s1> ^gtype predicate ^predicate <p1> ^list <l1>)
    (<p1>  ^parameter-set <p2> ^potential-args <p3>)
    (<p2>  ^tested calculate5 ^tested calculate2
          ^tested calculate6 ^tested calculate1 ^set <s2>)
    (<l1> ^game <g1>)
-->
    (<p1> ^instance <s2> +)
}
###################
### SATISYING CODE
###################
sp {satisfy-predicate-conditions*elaborate*result*set
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate5 ^tested calculate3 ^tested calculate2
          ^tested calculate6 ^tested calculate4 ^tested calculate1 ^iset <i1>)
   -{ (<p2> ^neg <neg1>)
      (<neg1> ^<ind4> <obj3>)
      (<i1> ^<ind4> <obj3>)}
   -{ (<p2> ^negpair3 <pair3>)
      (<pair3> ^<ind3> <objc> ^{ <> <ind3> <ind2> } <objb>
            ^{ <> <ind3> <> <ind2> <ind1> } <obja>)
      (<i1> ^<ind3> <objc> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<p2> ^negpair <pair>)
      (<pair> ^<ind2> <objb> ^{ <> <ind2> <ind1> } <obja>)
      (<i1> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<i1> ^<ind1> { <=> <i1> <obja> } ^<ind1> <obja>
            ^{ <> <ind1> <ind2> } <obja>)}
-->
    (<p2> ^set <i1> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*3-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 3)
    (<p1> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
#TODO how to reorder tests in rule
sp {satisfy-predicate-conditions*elaborate*initial-set*2-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 2)
    (<p1> ^1 <o1> ^2 <o2>)
   -{(<p2> ^neg <m>)
     (<m> ^2 <o2>)}
   -{(<p2> ^neg <q>)
     (<q> ^1 <o1>)}
   -{(<p2> ^negpair <p>)
    (<p> ^2 <o2> ^1 <o1>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*5-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 5)
    (<p1> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*6-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 6)
    (<p1> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair11>)
      (<pair11> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair16>)
      (<pair16> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair22>)
      (<pair22> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair25>)
      (<pair25> ^5 <o5> ^6 <o6>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*8-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 8)
    (<p1> ^8 <o8> ^7 <o7> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
  -{ (<p2> ^neg <n7>)
      (<n7> ^5 <o7>)}
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^8 <o8>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair11>)
      (<pair11> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair12>)
      (<pair12> ^2 <o2> ^7 <o7>)}
-{ (<p2> ^negpair <pair13>)
      (<pair13> ^2 <o2> ^8 <o8>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair16>)
      (<pair16> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair17>)
      (<pair17> ^3 <o3> ^7 <o7>)}
-{ (<p2> ^negpair <pair18>)
      (<pair18> ^3 <o3> ^8 <o8>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair22>)
      (<pair22> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair23>)
      (<pair23> ^4 <o4> ^7 <o7>)}
-{ (<p2> ^negpair <pair24>)
      (<pair24> ^4 <o4> ^8 <o8>)}
-{ (<p2> ^negpair <pair25>)
      (<pair25> ^5 <o5> ^6 <o6>)}
-{ (<p2> ^negpair <pair26>)
      (<pair26> ^5 <o5> ^7 <o7>)}
-{ (<p2> ^negpair <pair27>)
      (<pair27> ^5 <o5> ^8 <o8>)}
-{ (<p2> ^negpair <pair28>)
      (<pair28> ^6 <o6> ^7 <o7>)}
-{ (<p2> ^negpair <pair29>)
      (<pair29> ^6 <o6> ^8 <o8>)}
-{ (<p2> ^negpair <pair30>)
      (<pair30> ^7 <o2> ^8 <o8>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*7-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 7)
    (<p1> ^7 <o7> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n7>)
      (<n7> ^5 <o7>)}
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^7 <o7>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair11>)
      (<pair11> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair12>)
      (<pair12> ^2 <o2> ^7 <o7>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair16>)
      (<pair16> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair17>)
      (<pair17> ^3 <o3> ^7 <o7>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair22>)
      (<pair22> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair23>)
      (<pair23> ^4 <o4> ^7 <o7>)}
-{ (<p2> ^negpair <pair25>)
      (<pair25> ^5 <o5> ^6 <o6>)}
-{ (<p2> ^negpair <pair26>)
      (<pair26> ^5 <o5> ^7 <o7>)}
-{ (<p2> ^negpair <pair28>)
      (<pair28> ^6 <o6> ^7 <o7>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*16-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 16)
    (<p1> ^8 <o8> ^7 <o7> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>
          ^9 <o9> ^10 <o10> ^16 <o16> ^15 <o15> ^14 <o14> ^13 <o13> ^12 <o12> ^11 <o11>)
 -{ (<p2> ^neg <n10>)
      (<n10> ^1 <o10>)}
  -{ (<p2> ^neg <n11>)
      (<n11> ^11 <o11>)}
  -{ (<p2> ^neg <n16>)
      (<n16> ^16 <o16>)}
  -{ (<p2> ^neg <n15>)
      (<n15> ^15 <o15>)}
  -{ (<p2> ^neg <n14>)
      (<n14> ^14 <o14>)}
  -{ (<p2> ^neg <n13>)
      (<n13> ^13 <o13>)}
   -{ (<p2> ^neg <n12>)
      (<n12> ^12 <o12>)}
   -{ (<p2> ^neg <n9>)
      (<n9> ^9 <o9>)}  
-{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
  -{ (<p2> ^neg <n7>)
      (<n7> ^7 <o7>)}
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^16 <o16>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^2 <o2> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^2 <o2> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^2 <o2> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^2 <o2> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^16 <o16>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^3 <o3> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^3 <o3> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^3 <o3> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^3 <o3> ^16 <o16>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^4 <o4> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^4 <o4> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^4 <o4> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^4 <o4> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^4 <o4> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^4 <o4> ^16 <o16>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^5 <o5> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^5 <o5> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^5 <o5> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^5 <o5> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^5 <o5> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^5 <o5> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^5 <o5> ^16 <o16>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^6 <o6> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^6 <o6> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^6 <o6> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^6 <o6> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^6 <o6> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^6 <o6> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^7 <o7> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^7 <o7> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^7 <o7> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^7 <o7> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^7 <o7> ^16 <o16>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^8 <o8> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^8 <o8> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^8 <o8> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^8 <o8> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^8 <o8> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^8 <o8> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^9 <o9> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^9 <o9> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^9 <o9> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^9 <o9> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^9 <o9> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^9 <o9> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^9 <o9> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^10 <o10> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^10 <o10> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^10 <o10> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^10 <o10> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^10 <o10> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^10 <o10> ^16 <o16>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^11 <o11> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^11 <o11> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^11 <o11> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^11 <o11> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^11 <o11> ^16 <o16>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^12 <o12> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^12 <o12> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^12 <o12> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^12 <o12> ^16 <o16>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^13 <o13> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^13 <o13> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^13 <o13> ^16 <o16>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^14 <o14> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^14 <o14> ^16 <o16>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^15 <o15> ^16 <o16>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +
          ^9 <o9> ^10 <o10> ^16 <o16> ^15 <o15> ^14 <o14> ^13 <o13> ^12 <o12> ^11 <o11>)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*4-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 4)
    (<p1> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^4 <o4>)}
-->
    (<p2> ^iset <i1> +)
    (<i1>  ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}
sp {satisfy-predicate-conditions*elaborate*initial-set*1-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 1)
    (<p1> ^1 <o1>)
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> +)
}
#SAT work modify neg..
##### hmm had to revert... work around?
## problem cause locations that arnt near are not diagonal, need way  to only test arg1 and arg2 from same, when same..., in general wont work i think
## JK TODO here, also consider efficiency for increasing number of calculate3, check run -e 1
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*2-arguments
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^nlp-set.nlp <c1>)#^condition <c1>)#JK no nlp version, also look only at nlp
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p4> ^result <r1>)
    (<p4> ^num 2 ^2 <pp1> ^1 <pp2>) #not necessarily 1 and 2
    (<pp1> ^param-id <x1>)
    (<pp2> ^param-id <x2>)
    (<p3> ^<x2> <pp3> ^<x1> <pp4>)
   -{(<r1> ^set <s2>)
     (<s2> ^instance <p5>)
     (<p5> ^2 <pp4> ^1 <pp3>)}
    -->
    (<p2> ^negpair <n1> +)
    (<n1> ^<x2> <pp3> + ^<x1> <pp4> +)
}
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*2-arguments2
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <p1>)
    (<l1> ^game <g1>)
   (<p1> ^parameter-set <p2> ^potential-args <p3> ^nlp-set.conditions <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p4> ^result <r1>)
    (<p4> ^num 2 ^2 <pp1> ^1 <pp2>) #not necessarily 1 and 2
    (<pp1> ^param-id <x1>)
    (<pp2> ^param-id <x2>)
    (<p3> ^<x2> <pp3> ^<x1> <pp4>)
   -{(<r1> ^set <s2>)
     (<s2> ^instance <p5>)
     (<p5> ^2 <pp4> ^1 <pp3>)}
    -->
    (<p2> ^negpair <n1> +)
    (<n1> ^<x2> <pp3> + ^<x1> <pp4> +)
}
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*3-arguments
    (state <s1> ^gtype <c19> ^list <l1> ^<c19> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^potential-args <p2> ^nlp-set.nlp <c1>)#^condition <c1>)#JK nlp version
    (<p1> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^num 3 ^3 <*1> ^2 <*2> ^1 <*3>) #not necessarily 1 and 2 and 3
    (<*1> ^param-id <ar2>)
    (<*2> ^param-id <ar1>)
    (<*3> ^param-id <ar3>)
    (<p2> ^<ar3> <*4> ^<ar2> <*5> ^<ar1> <*6>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p4>)
      (<p4> ^1 <*4> ^3 <*5> ^2 <*6>)}
-->
    (<p1> ^negpair3 <n1> +)
    (<n1> ^<ar1> <*6> + ^<ar2> <*5> + ^<ar3> <*4> +)
}
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*3-arguments2
    (state <s1> ^gtype <c19> ^list <l1> ^<c19> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^potential-args <p2> ^nlp-set.conditions <c1>)# ^condition <c1>) #JK nlp version
    (<p1> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^num 3 ^3 <*1> ^2 <*2> ^1 <*3>) #not necessarily 1 and 2 and 3
    (<*1> ^param-id <ar2>)
    (<*2> ^param-id <ar1>)
    (<*3> ^param-id <ar3>)
    (<p2> ^<ar3> <*4> ^<ar2> <*5> ^<ar1> <*6>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p4>)
      (<p4> ^1 <*4> ^3 <*5> ^2 <*6>)}
-->
    (<p1> ^negpair3 <n1> +)
    (<n1> ^<ar1> <*6> + ^<ar2> <*5> + ^<ar3> <*4> +)
}
#damn problem with single neg to (if embedded)
#problem for now, just revert, look into change in create-from-parse, to make sure nlp if on top, also maybe anything with 2 or more paramids should be on top (nlp...)
#trade offs between both                                                                                                                                                               
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*1-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1> ^nlp-set.nlp <c1>) #^condition <c1>)##JK nlp version
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^<c6> <p4>)
    (<p4> ^param-id <c4>)
    (<p1> ^<c4> <o1>)
   -{(<r1> ^set <rs1>)
     (<rs1> ^instance <pp1>)
     (<pp1> ^<c6> <o1>)}
 -->
    (<p2> ^neg <n1> +)
    (<n1> ^<c4> <o1> +)
}
sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*1-argument2
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1> ^nlp-set.conditions <c1>)# ^condition <c1>)  #JK nlp version
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^<c6> <p4>)
    (<p4> ^param-id <c4>)
    (<p1> ^<c4> <o1>)
   -{(<r1> ^set <rs1>)
     (<rs1> ^instance <pp1>)
     (<pp1> ^<c6> <o1>)}
 -->
    (<p2> ^neg <n1> +)
    (<n1> ^<c4> <o1> +)
}
sp {satisfy-predicate-conditions*elaborate*potential-argument*number
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^nlp-set.nlp <c3>) #^condition <c3>)#  #JK nlp version
    (<c3> ^return-type number ^parameter <p3> ^result <r1> ^rtype single)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p3> ^<c4> <p4>) #tests existance of 1 to create possible of any
    (<p4> ^param-id <c6>) #^type single
    (<p5> ^<c4> <c7> ^1)
 -->
    (<p1> ^<c6> <c7> +)
}
sp {satisfy-predicate-conditions*elaborate*potential-argument*number2
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^nlp-set.conditions <c3>)# ^condition <c3>)  #JK nlp version
    (<c3> ^return-type number ^parameter <p3> ^result <r1> ^rtype single)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p3> ^<c4> <p4>) #tests existance of 1 to create possible of any
    (<p4> ^param-id <c6>) #^type single
    (<p5> ^<c4> <c7> ^1)
 -->
    (<p1> ^<c6> <c7> +)
}
#hmm this would be nice to only do from top... see if can keep with XQXQXQXQ change...
sp {satisfy-predicate-conditions*elaborate*potential-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^nlp-set.nlp <c1>)#^condition <c1>#JK nlp version uggg would be great to fix
    (<c1> ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <o2> ^{ << 1 2 3 4 5 >> <c4> } <o1>) #tests existance of non empty 1 to create possible of any
   -{ (<o2> -^<wme> <w*1>)
      (<s1> ^list <l*1>)}
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
-->
    (<p1> ^<c6> <o1> +)
}
sp {satisfy-predicate-conditions*elaborate*potential-argument2
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^nlp-set.conditions <c1>)# ^condition <c1>)  #JK nlp version
    (<c1> ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <o2> ^{ << 1 2 3 4 5 >> <c4> } <o1>) #tests existance of non empty 1 to create possible of any
   -{ (<o2> -^<wme> <w*1>)
      (<s1> ^list <l*1>)}
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
-->
    (<p1> ^<c6> <o1> +)
}