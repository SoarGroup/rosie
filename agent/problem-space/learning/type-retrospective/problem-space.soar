# Special rules for the selection space during retrospective learning


#retrospective-learning
#  state-no-change [learn-proposal-rule]
#    op-no-change [composite-action]

#sp {action*composite-action*learning*retrospective*best*preference*subaction
#   (state <s> ^superstate.name << learn-proposal-rule replay-subaction >>
#              ^operator <o> +
#              ^subactions.next.action-handle <handle>)
#   (<o> ^action-handle { <handle> << recall1 remember1 >> })
#-->
#   (<s> ^operator <o> >)
#}
#
#sp {action*compsoite-action*learning*retrospective*advance*subaction*applied
#   (state <s> ^superstate.name << learn-proposal-rule replay-subaction >>
#              ^operator <o>
#              ^subactions <subs>)
#   (<o> ^action-handle { <handle> << recall1 remember1 >> })
#   (<subs> ^next <cur>)
#   (<cur> ^action-handle <handle>
#          ^next <next>)
#-->
#   (<subs> ^next <cur> -
#           ^next <next>)
#}
       
sp {action*composite-action*learning*retrospective*elaborate*problem-space*subactions*copy-type
   (state <s> ^superstate.name << learn-proposal-rule replay-subaction >>
              ^problem-space <ps>)
   (<ps> ^name action
         ^learning.type retrospective)
-->
   (<ps> ^subactions.copy-type shallow)
}

#sp {action*composite-action*learning*retrospective*elaborate*desired*if*none
#   (state <s> ^superstate.name << learn-proposal-rule replay-subaction >>
#              ^problem-space.name action
#              ^problem-space.learning.type retrospective
#             -^desired.predicate)
#-->
#   (<s> ^desired <des>)
#}

sp {action*composite-action*learning*retrospective*elaborate*desired*satisfied*superstate
   (state <s> ^superstate.name << learn-proposal-rule replay-subaction >>
              ^problem-space.name action
              ^problem-space.learning.type retrospective
              ^desired.satisfied true
              ^superstate <ss>)
-->
   (<ss> ^desired.satisfied true)
}

#
#sp {action*composite-action*learning*retrospective*propose*change-subaction-arg
#   (state <s> ^name evaluate-operator
#              ^problem-space.name action
#              ^problem-space.learning.type retrospective
#              ^subactions <subs>
#              ^world.objects.object <ans>)
#   (<subs> ^answer <h>
#           ^next.<arg-name> <arg>)
#  (<arg> ^arg-type object
#         ^id <obj>)
#  (<ans> ^item-type object
#         ^predicates.modifier1 answer1)
#  (<obj> ^handle <h>)
#-->
#  (<s> ^operator <o> + > =)
#  (<o> ^name change-subaction-arg
#       ^argument <arg>
#       ^new-obj <ans>)
#}
#
#sp {action*composite-action*learning*retrospective*apply*change-subaction-arg
#   (state <s> ^name evaluate-operator
#              ^problem-space.name action
#              ^problem-space.learning.type retrospective
#              ^operator <o>)
#  (<o> ^name change-subaction-arg
#       ^argument <arg>
#       ^new-obj <new>)
#  (<arg> ^id <old>)
#-->
#  (<arg> ^id <old> -
#         ^id <new>)
#}
