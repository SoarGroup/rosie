#################################### concept #####################################

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*concept
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^<arg-name> <conc>)
   (<conc> ^item-type concept
          -^property.handle unit)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type concept
          ^arg-name <arg-name>
          ^source <conc>)
}

#################################### number #####################################

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*number
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^{ <arg-name> <> temporal-clause } <num-arg>
         -^{ <arg-name2> }.property.handle unit)
   (<num-arg> ^number <num>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type number
          ^arg-name <arg-name>
          ^source <num-arg>)
}

#################################### measure #####################################

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*measure
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^<arg-name1> <num-arg>
          ^<arg-name2> <unit-arg>)
   (<num-arg> ^handle <num> ^property.handle number)
   (<unit-arg> ^handle <unit> ^property.handle unit)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type measure
          ^arg-name <arg-name2>
          ^source <src>)
   (<src> ^number <num> ^unit <unit>)
}

#################################### modifiers #####################################

sp {task-utils*construct-task-operator*elaborate*modifiers
   (state <s> ^name construct-task-operator)
-->
   (<s> ^modifiers <mods>)
}

sp {task-utils*construct-task-operator*elaborate*has-modifiers*empty*false
   (state <s> ^name construct-task-operator
              ^modifiers <mods>)
   (<mods> ^handle <modh>)
-->
   (<mods> ^has-modifiers true)
}

# copy modifiers from the task operator
sp {task-utils*construct-task-operator*elaborate*modifiers*from*command-message
   (state <s> ^name construct-task-operator
              ^command-message.modifier.handle { <mod> <> upwards }
              ^modifiers <mods>)
-->
   (<mods> ^handle <mod>)
}

# copy modifiers from the TCN
sp {task-utils*construct-task-operator*elaborate*modifiers*from*tcn
   (state <s> ^name construct-task-operator
              ^task-concept-network.procedural.modifiers.mod-handle <mod>
              ^modifiers <mods>)
-->
   (<mods> ^handle <mod>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*modifiers
   (state <s> ^name construct-task-operator
              ^modifiers <mods>)
   (<mods> ^has-modifiers true)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type modifiers
          ^arg-name modifiers
          ^source <mods>)
}


#################################### object #####################################

# This will collect multiple objects with the same argument name into a single construct-task-argument

sp {task-utils*construct-task-operator*elaborate*object-argument-name
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^<arg-name> <obj>)
   (<obj> ^item-type object)
-->
   (<s> ^object-argument-name <arg-name>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*object
   (state <s> ^name construct-task-operator
              ^object-argument-name <arg-name>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type object
          ^arg-name <arg-name>)
}

# Elaborate every object as a potential source
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*object*source
   (state <s> ^name construct-task-operator
              ^construct-task-argument <cta>
              ^command-message <msg>)
   (<cta> ^arg-type object
          ^arg-name <arg-name>)
   (<msg> ^<arg-name> <obj>)
   (<obj> ^item-type object)
-->
   (<cta> ^source <obj>)
}

# Elaborate the reference-info onto the argument
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*object*reference-info
   (state <s> ^name construct-task-operator
              ^construct-task-argument <cta>
              ^command-message.reference-info <ref-info>)
   (<cta> ^arg-type object
          ^arg-name <arg-name>)
   (<ref-info> ^arg-name <arg-name>)
-->
   (<cta> ^reference-info <ref-info>)
}

# turn message argument from say/ask into an object
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*object*message
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^action.handle << say1 ask1 >>
          ^<arg-name>.sentence <sentence>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type object
          ^arg-name <arg-name>
          ^abstract true
          ^source <obj>
          ^reference-info <ref-info>)
   (<obj> ^item-type object
          ^handle (make-constant-symbol |obj-hand|)
          ^root-category message
          ^predicates <preds>)
   (<preds> ^category message
            ^sentence <sentence>)
   (<ref-info> ^constraint.category message
               ^constraint.sentence <sentence>)
}

### Turn ask agent -> arg2 object (the person to ask)
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*ask*agent
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^action.handle ask1
          ^agent.handle <name>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type object
          ^arg-name arg2
          ^source <obj>)
   (<obj> ^item-type object
          ^handle (make-constant-symbol |obj-hand|)
          ^root-category person
          ^predicates <preds>)
   (<preds> ^category person
            ^name <name>)
}

### Remember -> arg2 is abstract if arg3 is present
sp {task-utils*construct-task-operator*remember*elaborate*construct-task-argument*arg2*abstract
   (state <s> ^name construct-task-operator
              ^command-message <msg>
              ^construct-task-argument <arg2>)
   (<msg> ^action.handle remember1
          ^arg3 <arg3>)
   (<arg2> ^arg-type object
           ^arg-name arg2)
-->
   (<arg2> ^abstract true)
}


#################################### partial-predicate #####################################

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*partial-predicate
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^{ <arg-name> <> predicate <> relation } <arg>)
   (<arg> ^item-type predicate
          ^handle <handle>
          ^2 <obj2>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type partial-predicate
          ^arg-name <arg-name>
          ^source-name <arg-name>
          ^source <pred>)
   (<pred> ^handle <handle>
           ^2 <obj2>)
}

# If the partial-predicate is called predicate or relation, rename to arg2
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*partial-predicate*rel*arg2
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^{ <src-name> << predicate relation >> } <arg>)
   (<arg> ^item-type predicate
          ^handle <handle>
          ^2 <obj2>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type partial-predicate
          ^arg-name arg2
          ^source-name <src-name>
          ^source <pred>)
   (<pred> ^handle <handle>
           ^2 <obj2>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*predicate*arg2*relations
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^arg2.{2}.relations <arg2>)
   (<arg2> ^handle <handle>
           ^2 <obj2>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type partial-predicate
          ^arg-name arg1
          ^source <pred>)
   (<pred> ^handle <handle>
           ^2 <obj2>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*partial-predicate*reference-info
   (state <s> ^name construct-task-operator
              ^construct-task-argument <cta>
              ^command-message.reference-info <ref2>)
   (<cta> ^arg-type partial-predicate
          ^source-name <src-name>)
   (<ref2> ^arg-name <src-name>)
-->
   (<cta> ^reference-info.2 <ref2>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*partial-predicate*reference-info*weird*case
   (state <s> ^name construct-task-operator
              ^construct-task-argument <cta>
              ^command-message.reference-info <ref2>)
   (<cta> ^arg-type partial-predicate
          ^source-name predicate)
   (<ref2> ^arg-name relation)
-->
   (<cta> ^reference-info.2 <ref2>)
}

#################################### temporal-clause #####################################

# Start Clause
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*start-clause
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^temporal-predicate.handle << after1 when1 at1 >>
          ^temporal-clause <clause>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type temporal-clause
          ^arg-name start-clause
          ^message-clause <clause>)
}

# End Clause
sp {task-utils*construct-task-operator*elaborate*construct-task-argument*end-clause
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^temporal-predicate.handle << until1 while1 for1 >>
          ^temporal-clause <clause>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type temporal-clause
          ^arg-name end-clause
          ^message-clause <clause>)
}

### Duration Predicate
sp {task-utils*construct-task-operator*temporal-clause*duration*construct-predicate-set
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^number <num>
             ^unit <unit>)
-->
   (<arg> ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type duration
            ^number <num>
            ^unit <unit>)
}

### Clocktime Predicate
sp {task-utils*construct-task-operator*temporal-clause*clocktime*construct-predicate-set
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^hour <hour>
             ^minute <min>)
-->
   (<arg> ^source <src>)
   (<src> ^type start
          ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type clocktime
            ^hour <hour>
            ^minute <min>)
}

### Sense
sp {task-utils*construct-task-operator*temporal-clause*elaborate*predicate-set*sense
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^action.handle sense1
             ^arg1 <obj>)
   (<obj> -^item-type concept)
-->
   (<arg> ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type unary
            ^handle visible1
            ^1 <obj>)
}

### 1 Unary Predicate
sp {task-utils*construct-task-argument*temporal-clause*elaborate*predicate-set*unary
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^action.handle is1
             ^arg1 <obj>
            -^arg2
             ^predicate.handle <pred-h>)
   (<obj> -^item-type concept)
-->
   (<arg> ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type unary
            ^handle <pred-h>
            ^1 <obj>)
}

### 2 unary predicates
sp {task-utils*construct-task-argument*temporal-clause*elaborate*predicate-set*2*unary
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^subclause <sub1> { <sub2> > <sub1> })
   (<sub1> ^action.handle is1
           ^arg1 <obj1>
           ^predicate.handle <pred1-h>)
   (<sub2> ^action.handle is1
           ^arg1 <obj2>
           ^predicate.handle <pred2-h>)
   (<obj1> -^item-type concept)
   (<obj2> -^item-type concept)
-->
   (<arg> ^source <src>)
   (<src> ^pred-count 2
          ^1 <pred1>
          ^2 <pred2>)
   (<pred1> ^type unary
            ^handle <pred1-h>
            ^1 <obj1>)
   (<pred2> ^type unary
            ^handle <pred2-h>
            ^1 <obj2>)
}

### contains predicate
sp {task-utils*construct-task-argument*temporal-clause*elaborate*predicate-set*contains
   (state <s> ^construct-task-argument <arg>)
   (<arg> ^arg-type temporal-clause
          ^message-clause <clause>)
   (<clause> ^predicate.handle contains1
             ^arg1 <obj1>
             ^arg2.handle <liquid>)
   (<obj1> -^item-type concept)
-->
   (<arg> ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type unary
            ^handle <liquid>
            ^property-handle contents1
            ^1 <obj1>)
}

### copy reference-info 1 unary predicate
sp {task-utils*construct-task-operator*temporal-clause*elaborate*reference-info*1*unary
   (state <s> ^name construct-task-operator
              ^construct-task-argument <cta>)
   (<cta> ^arg-type temporal-clause
          ^message-clause.reference-info <ref>
          ^source.{1} <pred1>)
   (<ref> ^arg-name arg1)
-->
   (<pred1> ^reference-info <ref-info>)
   (<ref-info> ^1 <ref>)
}

#################################### conditions #####################################

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*condition*1*predicate
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^conditions <conds>)
   (<conds> ^action.handle is1
           ^arg1 <obj>
           ^predicate <ppred>
           ^reference-info <ref1>)
   (<ppred> ^handle <ph>
           -^2 <obj2>)
   (<ref1> ^arg-name arg1)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type conditions
          ^arg-name conditions
          ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type unary
            ^handle <ph>
            ^1 <obj>
            ^reference-info.1 <ref1>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*condition*1*relation
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^conditions <conds>)
   (<conds> ^action.handle is1
            ^arg1 <obj1>
            ^predicate <ppred>
            ^reference-info <ref1>
            ^reference-info <ref2>)
   (<ppred> ^handle <ph>
            ^2 <obj2>)
   (<ref1> ^arg-name arg1)
   (<ref2> ^arg-name relation)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type conditions
          ^arg-name conditions
          ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type relation
            ^handle <ph>
            ^1 <obj1>
            ^2 <obj2>
            ^reference-info <ri-new>)
   (<ri-new> ^1 <ref1> ^2 <ref2>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*condition*1*predicate*current-location
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^conditions <conds>)
   (<conds> ^action.handle is1
            ^arg1.handle rosie
            ^predicate <pred>)
   (<pred> ^handle in1
           ^2 <loc>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type conditions
          ^arg-name conditions
          ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type status
            ^name current-location
            ^1 <loc>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*condition*1*pred*sense
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^conditions <conds>)
   (<conds> ^action.handle sense1
            ^agent.handle rosie
            ^arg1 <obj>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type conditions
          ^arg-name conditions
          ^source <src>)
   (<src> ^pred-count 1
          ^1 <pred1>)
   (<pred1> ^type unary
            ^handle visible1
            ^1 <obj>)
}

sp {task-utils*construct-task-operator*elaborate*construct-task-argument*condition*2*predicates
   (state <s> ^name construct-task-operator
              ^command-message <msg>)
   (<msg> ^conditions <conds>)
   (<conds> ^predicate <p1> { <p2> > <p1> })
   (<p1> ^handle <pred1> 
         ^property.handle <prop1>)
   (<p2> ^handle { <pred2> <> <pred1> }
         ^property.handle <prop2>)
-->
   (<s> ^construct-task-argument <cta>)
   (<cta> ^arg-type conditions
          ^arg-name conditions
          ^source <src>)
   (<src> ^pred-count 1
          ^1 <src-pred1>)
   (<src-pred1> ^type object-exists
                ^pred-count 2
                ^1 <sp1>
                ^2 <sp2>)
   (<sp1> ^property-handle <prop1> ^predicate-handle <pred1>)
   (<sp2> ^property-handle <prop2> ^predicate-handle <pred2>)
}

