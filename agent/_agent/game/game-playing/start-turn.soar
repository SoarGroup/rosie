#sp {chunk-9*d3117*tie*1
#    :chunk
#    (state <s1> ^problemspace action ^name op_1 ^desired <d1>
#          ^not-tracking <n1> ^object <p1> ^object <p2> ^operator <o1> +
#          ^problem-space <p3>)
#    (<d1> -^achieve-state <a1> ^track-relation <n1>)
#    (<n1> ^p2 <p1> ^p1 <p2> ^relation <r1>)
#    (<p1> ^focus constant5p2 ^focus op_1argument4)
#    (<p2> ^focus op_1argument3)
#    (<o1> ^argument1 <p2> ^name op_pick-up-object)
#    (<p3> ^name op_1)
#    -->
#    (<s1> ^operator <o1> >)
#}
#
#sp {chunk-8*d3116*tie*1
#    :chunk
#    (state <s1> ^problemspace action ^name op_1 ^desired <d1>
#          ^not-tracking <n1> ^grabbed <g1> ^object <g1> ^operator <o1> +
#          ^problem-space <p3>)
#    (<d1> -^achieve-state <a1> ^track-relation <n1>)
#    (<n1> ^p2 <p1> ^p1 <p2> ^relation <r1>)
#    (<p1> ^focus op_1argument4)
#    (<p2> ^focus op_1argument3)
#    (<g1> ^focus op_1argument3)
#    (<o1> ^argument1 <g1> ^name op_put-down-object-location ^argument2 <a2>)
#    (<p3> ^name op_1)
#    (<a2> ^argument <a3> ^relation <r1>)
#    (<a3> ^focus op_1argument4)
#    -->
#    (<s1> ^operator <o1> >)
#}
#
#sp {chunk-6*d3115*tie*3
#    :chunk
#    (state <s1> ^problemspace action ^name op_1 ^problem-space <p1>
#          ^desired <d1> ^operator <o1> +)
#    (<p1> ^name op_1)
#    (<d1> ^track-relation <t1>)
#    (<t1> ^p2 <p2> ^relation <r1>)
#    (<p2> ^focus op_1argument4)
#    (<o1> ^argument2 <a1>)
#    (<a1> ^argument <a2>)
#    (<a2> ^focus op_1argument4)
#    -->
#    (<a1> ^relation <r1> +)
#}
#
#sp {chunk-4*d3115*tie*1
#    :chunk
#    (state <s1> ^problemspace action ^name op_1 ^problem-space <p1>
#          ^desired <d1> ^operator <o1> +)
#    (<p1> ^name op_1)
#    (<d1> ^track-relation <t1>)
#    (<t1> ^p2 <p2> ^relation <r1>)
#    (<p2> ^focus constant5p2)
#    (<o1> ^argument2 <a1>)
#    (<a1> ^argument <a2>)
#    (<a2> ^focus constant5p2)
#    -->
#    (<a1> ^relation <r1> +)
#}
#
##sp {chunk-3*d3114*tie*3
##    :chunk
##    (state <s1> ^problemspace action ^superstate <s2> ^operator <o1> +)
##    (<s2> ^relevant-segment-id 100101)
##    (<o1> ^argument2 <a1>)
##    (<a1> ^argument <a2>)
##    (<a2> ^id 3)
##    -->
##    (<a1> ^relation <r1> +)
##    (<r1> ^smem-rep @P2 +)
##}
#
#sp {chunk-2*d3114*unknownimpasse*2
#    :chunk
#    (state <s1> ^problemspace action ^desired <d1> ^operator <o1> +)
#    (<d1> ^track-relation <t1>)
#    (<t1> ^p2 <p1> ^relation <r1>)
#    (<p1> ^focus constant5p2)
#    (<o1> ^argument2 <a1>)
#    (<a1> ^argument <a2>)
#    (<a2> ^focus constant5p2)
#    -->
#    (<a1> ^relation <r1> +)
#}
#
#sp {chunk-1*d3114*unknownimpasse*1
#    :chunk
#    (state <s1> ^problemspace action ^desired <d1> ^operator <o1> +)
#    (<d1> ^track-relation <t1>)
#    (<t1> ^p2 <p1> ^relation <r1>)
#    (<p1> ^focus op_1argument4)
#    (<o1> ^argument2 <a1>)
#    (<a1> ^argument <a2>)
#    (<a2> ^focus op_1argument4)
#    -->
#    (<a1> ^relation <r1> +)
#}



sp {start-turn*propose*find-action
   (state <s> ^name start-turn
             -^action)
-->
   (<s> ^operator <o> + =)
   (<o> ^name find-action
        ^category svs) # for now determine better or new category)
}
#handle failed object/action look up
sp {start-turn*propose*do-action
   (state <s> ^name start-turn
              ^action <action>
              ^predicate <p>
             -^success
              ^obj1 <oa>
              ^obj2 <ob>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name do-action
        ^category svs
        ^action <action>
        ^predicate <p>
        ^obj1 <oa>
        ^obj2 <ob>)
}

sp {do-action*propose*comprehend-action-command
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
             -^found-op
              ^predicate <p>
              ^obj2 <ob>)
   (<action> ^verb <verb-word>)
-->
   (interrupt)
   (<s> ^operator <o> + = )
   (<o> ^name comprehend-action-command ^parameter <pa> ^initialized true)
   (<pa> ^direct-object <do-param>
       ^pp-object <po-param>
       ^verb <verb-param>
       ^type action-command)
   (<do-param> ^type direct-object
               ^result <oa>)
   (<po-param> ^type pp-object
               ^result <res1>)
   (<res1> ^object <ob>)
#           ^relation.smem-rep <p>)
   (<verb-param> ^type verb
                 ^lexical <verb-word>)
}

sp {do-action*apply*comprehend-action-command
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
              ^predicate <p>
              ^operator <o>)
   (<o> ^name comprehend-action-command 
        ^parameter <pa>)
   (<pa> ^result <op>)
-->
   (<s> ^found-op <op>)
}

#sp {action*propose*found-operator
#   (state <s> ^name action
#              ^superstate.operator.found-op <op>)
#-->
#   (interrupt)
#   (<s> ^operator <op> + >)
#}

sp {do-action*store*topaction
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
              ^topstate <ts>
              ^found-op <op>
              ^predicate <p1>
              ^obj2 <ob>)
-->
   (interrupt)
   (<ts> ^action-todo <op>)
#   (<s> ^operator <o> +)
#   (<o> ^name action
#        ^found-op <op>
#        ^purpose <p>)
#   (<p> ^satisfaction.action-event complex-action)
}
sp {do-action*propose*topstateaction
   (state <s> ^topstate <s>
              ^action-todo <op>)
   (<op> -^applied true)
-->
   (<s> ^operator <o> +)
   (<o> ^name action
        ^purpose <p>
        ^indexed-action <op>)
}

#sp {do-action*elaborate*cue
#   (state <s> ^name do-action
#              ^action <action>
#              ^obj1 <oa>
#              ^obj2 <ob>)
#   (<action> ^verb <verb>)
#-->
#   (<s> ^cue <cue>)
#   (<cue> ^direct-object <oa> ^to <ob> ^verb <verb>)
#}
#
#sp {do-action*elaborate*mcue
#   (state <s> ^name do-action
#              ^action <action>
#              ^obj1 <oa>
#              ^obj2 <ob>)
#   (<action> ^verb <verb>)
#-->
#   (<s> ^mcue <mcue>)
#   (<mcue> ^direct-object <n1> ^to <n2> ^verb <verb>)
#}
#
#### propose lookup semantic memory
#sp {do-action*propose*lookup*semantic-memory
#   (state <s> ^name do-action
#   	      ^mcue <cue>
#	      -^linguistic <any>)
#  -->
#   (<s> ^operator <op> +)
#   (<op> ^name get-linguistic-id
#   	 ^cue <cue>
#	 ^category indexing)
#}
#
#
#### retrieved id is the lid for the linguistic structure of the verb
#sp {do-action*propose*get-parent-map
#   (state <s> ^name do-action
#   	      ^linguistic <ling>
#	      -^map-id <map>)
#-->
#   (<s> ^operator <op> + =)
#   (<op> ^name get-map-id
#   	 ^linguistic <ling>
#	 ^category indexing)
#}
#
#### get procedural knowledge for the map
#sp {do-action*propose*get-procedural
#   (state <s> ^name do-action
#   	      ^map-id <map>
#	      -^procedural <proc>)
#  -->
#  (<s> ^operator <op> + =)
#  (<op> ^name get-procedural-id
#  	^map-id <map>
#	^category indexing)
#}
#
#### generate the structure of the new operator
#sp {do-action*propose*generate-operator
#   (state <s> ^name do-action
#   	      ^procedural <pid>
#	      ^linguistic <lid>
#	      ^map-id <map>
#	      ^cue <cue>
#	      -^indexed-operator <any>)
#-->
#  (<s> ^operator <op> +)
#  (<op> ^name generate-operator
#  	^procedural-id <pid>
#	^linguistic-id <lid>
#	^cue <cue>
#	^map-id <map>
#	^category indexing)
#}
#
#sp {do-action*propose*operator
#   (state <s> ^name do-action
#              ^action <action>
#              ^obj1 <oa>
#              ^obj2 <ob>
#             -^success
#              ^indexed-operator <map-op>)
# -->
#   (<s> ^operator <map-op> +)
#   (<map-op> ^category composite-action #composite-action
#	     ^indexed-operator <map-op>)
#}


sp {do-action*finish*operator
   (state <s> ^name do-action
              ^superstate <ss>
              ^success <suc>)
-->
   (<ss> ^success true)
}

sp {start-turn*propose*complete-turn
   (state <s> ^name start-turn
#              ^impasse no-change
              ^success
#              ^attribute state
              ^action)
 -->
   (<s> ^operator <o> +)
   (<o> ^name complete-turn
        ^category svs)
}
sp {start-turn*propose*wait
   (state <s> ^name complete-turn
   	     -^operator.name wait)
 -->
   (<s> ^operator <o> +)
   (<o> ^name wait
        ^category svs)
}

##sp {start-turn*apply*complete-turn
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^operator <o>)
##   (<o> ^name complete-turn)
##-->
##   (interrupt)
##   
##   (<s> ^action <a> -)
##}
#
##sp {start-turn*apply*remove-stale-svs-extracts
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^topstate.svs.command <cmd>
##              ^operator <o>)
##   (<o> ^name complete-turn)
##   (<cmd> ^{<arg> << extract_once extract project >>} <E11>)
##   (<E11> ^a <N7> ^b <N8>)
##-->
##   (<cmd> ^<arg> <E11> -)
##}
##sp {start-turn*apply*remove-stale-svs-project
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^topstate.svs.command <cmd>
##              ^operator <o>)
##   (<o> ^name complete-turn)
##   (<cmd> ^project <E11>)
##-->
##   (<cmd> ^project <E11> -)
##}


#sp {start-turn*apply*complete-turn
#   (state <s> ^name start-turn
#              ^topstate.status <status>
#              ^topstate <ts>
#              ^action <a>
#             -^solved
#              ^topstate.self.action wait
#              ^topstate.self.prev-action drop
#              ^operator <o>)
#   (<o> ^name complete-turn)
#-->
#   (<status> ^performed.action-event.type turn) 
#   (<ts> ^instructor-message <msg>)
#   (<msg> ^type object-message
#          ^information.object.word turn)
#}

sp {start-turn*apply*complete-turn
   (state <s> ^name start-turn
              ^topstate.interaction.status <status>
              ^topstate <ts>
              ^action <a>
              ^obj1 <o1>
              ^obj2 <o2>
              ^success <suc>
             -^solved
              ^topstate.track-relation <tr>
              ^topstate.self.action wait
              ^topstate.self.prev-action drop
              ^topstate.flound-action <fa>
              ^operator <o>)
   (<o> ^name complete-turn)
   (<o1> ^focus <f1>)
   (<o2> ^focus <f2>)
   (<fa> ^obj1 <oa> ^obj2 <ob> ^dcount <dc> -^mark)
  -{(<ts> ^flound-action <fa2>)
    (<fa2> -^mark ^dcount < <dc>)}      
-->
#   (interrupt)
   (<s> ^action <a> -)
   (<s> ^obj1 <o1> -)
   (<s> ^obj2 <o2> -)
   (<s> ^success <suc> -)
   (<ts> ^track-relation <tr> -)
   (<o1> ^focus <f1> -)
   (<o2> ^focus <f2> -)
#   (<s> ^obj1 <oa>)
#   (<s> ^obj2 <ob>)
}

sp {start-turn*apply*complete-turn*solved*did-all-actions
   (state <s> ^name start-turn
              ^topstate.interaction.status <status>
              ^action <a>
              ^topstate <ts>
              ^topstate.flound-action <fa>
              ^topstate.self.action wait
              ^topstate.self.prev-action drop
              ^operator <o>)
   (<fa> ^dcount <dc> ^mark)
  -{(<ts> ^flound-action <fa2>)
    (<fa2> ^dcount > <dc>)}    
   (<o> ^name complete-turn)
-->
#   (interrupt)
   (<status> ^performed.action-event.type turn) 
}

sp {start-turn*apply*complete-turn*solved
   (state <s> ^name start-turn
              ^topstate.interaction.status <status>
              ^action <a>
              ^solved
              ^topstate.self.action wait
              ^topstate.self.prev-action drop
              ^operator <o>)
   (<o> ^name complete-turn)
-->
   (<status> ^performed.action-event.type turn) 
}