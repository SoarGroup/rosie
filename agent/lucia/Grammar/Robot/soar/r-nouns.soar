#   Soar code produced automatically 
#   from file 'C:\Users\plind\OneDrive\GitHub\PLCode\Lucia\Grammars\Robot\ecg\r-nouns.ecg'.

#   QUOTED-STRING construction
sp {comprehend-word*apply*lexical-access*QUOTED-STRING
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth <orth>
           ^content <content1>
           ^is-quoted true)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name QUOTED-STRING
          ^is <a>
          ^orth <orth>
          ^text <content1>
          ^f <word>
          ^m <meaning>
          ^first-lex nil)
   (<a> ^a QUOTED-STRING)
}

#   FORK construction
sp {comprehend-word*apply*lexical-access*FORK-fork
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |fork|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name FORK
          ^is <a>
          ^orth |fork|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a FORK)
   (<e-meaning> ^schema Fork
                ^target <meaning>)
}

#   DRAWER construction
sp {comprehend-word*apply*lexical-access*DRAWER-drawer
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |drawer|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name DRAWER
          ^is <a>
          ^orth |drawer|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a DRAWER)
   (<e-meaning> ^schema Drawer
                ^target <meaning>)
}

#   MUG construction
sp {comprehend-word*apply*lexical-access*MUG-mug
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |mug|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name MUG
          ^is <a>
          ^orth |mug|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a MUG)
   (<e-meaning> ^schema Mug
                ^target <meaning>)
}

#   FRIDGE construction
sp {comprehend-word*apply*lexical-access*FRIDGE-fridge
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |fridge|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name FRIDGE
          ^is <a>
          ^orth |fridge|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a FRIDGE)
   (<e-meaning> ^schema Fridge
                ^target <meaning>)
}

#   DEGREES construction
sp {comprehend-word*apply*lexical-access*DEGREES-degrees
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |degrees|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name DEGREES
          ^is <a>
          ^orth |degrees|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of UnitsName
          ^first-lex nil)
   (<a> ^a DEGREES)
}

#   DEGREES self.m.type <-- "angle" constraint
sp {comprehend-word*DEGREES-constraint*self-m-type*ASSIGN*angle
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DEGREES
          ^orth |degrees|
          ^m <l-slot1>)
   (<l-slot1> ^type { <target> <> |angle| })
-->
   (<l-slot1> ^type <target> -
              ^type |angle|)
}

#   DEGREES self.m.concept-handle <-- "degrees" constraint
sp {comprehend-word*DEGREES-constraint*self-m-concept-handle*ASSIGN*degrees
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DEGREES
          ^orth |degrees|
          ^m <l-slot1>)
   (<l-slot1> ^concept-handle { <target> <> |degrees| })
-->
   (<l-slot1> ^concept-handle <target> -
              ^concept-handle |degrees|)
}

#   APPLE construction
sp {comprehend-word*apply*lexical-access*APPLE-apple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |apple|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name APPLE
          ^is <a>
          ^orth |apple|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a APPLE)
   (<e-meaning> ^schema Apple
                ^target <meaning>)
}

#   JUICE construction
sp {comprehend-word*apply*lexical-access*JUICE-juice
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |juice|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name JUICE
          ^is <a>
          ^orth |juice|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a JUICE)
   (<e-meaning> ^schema Juice
                ^target <meaning>)
}

#   WATER construction
sp {comprehend-word*apply*lexical-access*WATER-water
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |water|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name WATER
          ^is <a>
          ^orth |water|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a WATER)
   (<e-meaning> ^schema Water
                ^target <meaning>)
}

#   MILK construction
sp {comprehend-word*apply*lexical-access*MILK-milk
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |milk|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name MILK
          ^is <a>
          ^orth |milk|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a MILK)
   (<e-meaning> ^schema Milk
                ^target <meaning>)
}

