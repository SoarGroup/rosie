#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\locations.ecg'.

#   RosieLocation schema
sp {comprehend-word*evoked-schema*RosieLocation*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema RosieLocation
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name RosieLocation
               ^is <a>
               ^rosie-category nil
               ^name nil
               ^category nil
               ^root-category nil)
   (<a> ^a RosieLocation)
}

#   RosieLocation schema
sp {comprehend-word*evoked-schema*RosieLocation*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema RosieLocation
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^rosie-category nil
               ^name nil
               ^category nil
               ^root-category nil)
   (<a> ^a RosieLocation)
}

#   Stove schema
sp {comprehend-word*evoked-schema*Stove*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Stove
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Stove
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Stove)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value stove)
}

#   Stove schema
sp {comprehend-word*evoked-schema*Stove*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Stove
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Stove)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value stove)
}

#   Pantry schema
sp {comprehend-word*evoked-schema*Pantry*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Pantry
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Pantry
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Pantry)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value pantry)
}

#   Pantry schema
sp {comprehend-word*evoked-schema*Pantry*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Pantry
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Pantry)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value pantry)
}

#   Garbage schema
sp {comprehend-word*evoked-schema*Garbage*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Garbage
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Garbage
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Garbage)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value garbage)
}

#   Garbage schema
sp {comprehend-word*evoked-schema*Garbage*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Garbage
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Garbage)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value garbage)
}

#   Table schema
sp {comprehend-word*evoked-schema*Table*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Table
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Table
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Table)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value table)
   (<c3> ^attr category
         ^value table1)
}

#   Table schema
sp {comprehend-word*evoked-schema*Table*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Table
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Table)
   (<e1> ^schema RosieLocation
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<c1> ^attr rosie-category
         ^value location)
   (<c2> ^attr name
         ^value table)
   (<c3> ^attr category
         ^value table1)
}

