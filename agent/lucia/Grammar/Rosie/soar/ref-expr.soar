#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\ref-expr.ecg'.

#   RefExpr construction
sp {comprehend-word*generalize-cxn*RefExpr*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of RefExpr
          ^is <a>)
   (<a> -^a RefExpr)
-->
   (<a> ^a RefExpr)
   (<cxn> ^subcase-of RefExpr -)
}

#   Propose an operator for the RefExprPrepPhrase construction
sp {comprehend-word*propose*match-construction*RefExprPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prepPhrase>)
   (<prepPhrase> ^is.a PrepPhrase
                 ^previous <refExpr>)
   (<refExpr> ^is.a RefExpr
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefExprPrepPhrase
        ^span 2
        ^lexicals 0
        ^prepPhrase <prepPhrase>
        ^refExpr <refExpr>
        ^previous <previous>
        ^debug-info (concat |Match a RefExprPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the RefExprPrepPhrase construction
sp {comprehend-word*apply*match-construction*RefExprPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefExprPrepPhrase
        ^refExpr <refExpr>
        ^prepPhrase <prepPhrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefExprPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RefExpr
              ^constituents <constituents>
              ^refExpr <refExpr>
              ^prepPhrase <prepPhrase>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RefExprPrepPhrase)
   (<constituents> ^refExpr <refExpr>
                   ^prepPhrase <prepPhrase>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefExprPrepPhrase construction.|))
}

#   RefExprPrepPhrase self.m.category <--> refExpr.m.category constraint
sp {comprehend-word*RefExprPrepPhrase-constraint*self-m-category*UNIFY*refexpr-m-category
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprPrepPhrase
          ^m <l-slot1>
          ^refExpr <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^category <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   RefExprPrepPhrase self.m.givenness <--> refExpr.m.givenness constraint
sp {comprehend-word*RefExprPrepPhrase-constraint*self-m-givenness*UNIFY*refexpr-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprPrepPhrase
          ^m <l-slot1>
          ^refExpr <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   RefExprPrepPhrase self.m.modifiers <--> refExpr.m.modifiers constraint
sp {comprehend-word*RefExprPrepPhrase-constraint*self-m-modifiers*UNIFY*refexpr-m-modifiers
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprPrepPhrase
          ^m <l-slot1>
          ^refExpr <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^modifiers <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   RefExprPrepPhrase self.m.referent <--> refExpr.m.referent constraint
sp {comprehend-word*RefExprPrepPhrase-constraint*self-m-referent*UNIFY*refexpr-m-referent
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprPrepPhrase
          ^m <l-slot1>
          ^refExpr <r-slot1>)
   (<l-slot1> ^referent { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^referent <value>)
-->
   (<l-slot1> ^referent <target> -
              ^referent <value>)
}

#   RefExprPrepPhrase self.m.relation <--> prepPhrase.m constraint
sp {comprehend-word*RefExprPrepPhrase-constraint*self-m-relation*UNIFY*prepphrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprPrepPhrase
          ^m <l-slot1>
          ^prepPhrase <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   Propose an operator for the BareNoun construction
sp {comprehend-word*propose*match-construction*BareNoun
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <noun>)
   (<noun> ^is.a CommonNoun
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name BareNoun
        ^span 1
        ^lexicals 0
        ^noun <noun>
        ^previous <previous>
        ^debug-info (concat |Match a BareNoun construction, combination 0.|))
}

#   Apply the operator for the BareNoun construction
sp {comprehend-word*apply*match-construction*BareNoun
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name BareNoun
        ^noun <noun>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name BareNoun
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RefExpr
              ^constituents <constituents>
              ^noun <noun>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a BareNoun)
   (<constituents> ^noun <noun>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a BareNoun construction.|))
}

#   BareNoun self.m.name <--> noun.m.schema-name constraint
sp {comprehend-word*BareNoun-constraint*self-m-name*UNIFY*noun-m-schema-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a BareNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^name { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^schema-name <value>)
-->
   (<l-slot1> ^name <target> -
              ^name <value>)
}

#   BareNoun self.m.category <--> noun.m constraint
sp {comprehend-word*BareNoun-constraint*self-m-category*UNIFY*noun-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a BareNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   BareNoun self.m.givenness <-- "indeterminate" constraint
sp {comprehend-word*BareNoun-constraint*self-m-givenness*ASSIGN*indeterminate
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a BareNoun
          ^m <l-slot1>)
   (<l-slot1> ^givenness { <target> <> |indeterminate| })
-->
   (<l-slot1> ^givenness <target> -
              ^givenness |indeterminate|)
}

#   SpecifierNP construction
sp {comprehend-word*generalize-cxn*SpecifierNP*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of SpecifierNP
          ^is <a>)
   (<a> -^a SpecifierNP)
-->
   (<a> ^a SpecifierNP)
   (<cxn> ^subcase-of SpecifierNP -
          ^subcase-of RefExpr)
}

#   Propose an operator for the SpecNoun construction
sp {comprehend-word*propose*match-construction*SpecNoun
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <noun>)
   (<noun> ^is.a CommonNoun
           ^previous <spec>)
   (<spec> ^is.a NPSpecifier
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SpecNoun
        ^span 2
        ^lexicals 0
        ^noun <noun>
        ^spec <spec>
        ^previous <previous>
        ^debug-info (concat |Match a SpecNoun construction, combination 0.|))
}

#   Apply the operator for the SpecNoun construction
sp {comprehend-word*apply*match-construction*SpecNoun
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SpecNoun
        ^spec <spec>
        ^noun <noun>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SpecNoun
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of SpecifierNP
              ^constituents <constituents>
              ^spec <spec>
              ^noun <noun>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SpecNoun)
   (<constituents> ^spec <spec>
                   ^noun <noun>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SpecNoun construction.|))
}

#   SpecNoun self.m.name <--> noun.m.schema-name constraint
sp {comprehend-word*SpecNoun-constraint*self-m-name*UNIFY*noun-m-schema-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^name { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^schema-name <value>)
-->
   (<l-slot1> ^name <target> -
              ^name <value>)
}

#   SpecNoun self.m.category <--> noun.m constraint
sp {comprehend-word*SpecNoun-constraint*self-m-category*UNIFY*noun-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   SpecNoun self.m.givenness <--> spec.m.givenness constraint
sp {comprehend-word*SpecNoun-constraint*self-m-givenness*UNIFY*spec-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecNoun
          ^m <l-slot1>
          ^spec <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   Propose an operator for the SpecPropNoun construction
sp {comprehend-word*propose*match-construction*SpecPropNoun
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <noun>)
   (<noun> ^is.a CommonNoun
           ^previous <prop>)
   (<prop> ^is.a Property
           ^previous <spec>)
   (<spec> ^is.a NPSpecifier
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SpecPropNoun
        ^span 3
        ^lexicals 0
        ^noun <noun>
        ^prop <prop>
        ^spec <spec>
        ^previous <previous>
        ^debug-info (concat |Match a SpecPropNoun construction, combination 0.|))
}

#   Apply the operator for the SpecPropNoun construction
sp {comprehend-word*apply*match-construction*SpecPropNoun
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SpecPropNoun
        ^spec <spec>
        ^prop <prop>
        ^noun <noun>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SpecPropNoun
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of SpecifierNP
              ^constituents <constituents>
              ^spec <spec>
              ^prop <prop>
              ^noun <noun>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SpecPropNoun)
   (<constituents> ^spec <spec>
                   ^prop <prop>
                   ^noun <noun>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SpecPropNoun construction.|))
}

#   SpecPropNoun self.m.name <--> noun.m.schema-name constraint
sp {comprehend-word*SpecPropNoun-constraint*self-m-name*UNIFY*noun-m-schema-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecPropNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^name { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^schema-name <value>)
-->
   (<l-slot1> ^name <target> -
              ^name <value>)
}

#   SpecPropNoun self.m.category <--> noun.m constraint
sp {comprehend-word*SpecPropNoun-constraint*self-m-category*UNIFY*noun-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecPropNoun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   SpecPropNoun self.m.givenness <--> spec.m.givenness constraint
sp {comprehend-word*SpecPropNoun-constraint*self-m-givenness*UNIFY*spec-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecPropNoun
          ^m <l-slot1>
          ^spec <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   SpecPropNoun self.m.modifiers <--> prop.m constraint
sp {comprehend-word*SpecPropNoun-constraint*self-m-modifiers*UNIFY*prop-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecPropNoun
          ^m <l-slot1>
          ^prop <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   Propose an operator for the SpecProps2Noun construction
sp {comprehend-word*propose*match-construction*SpecProps2Noun
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <noun>)
   (<noun> ^is.a CommonNoun
           ^previous <props2>)
   (<props2> ^is.a Properties2
             ^previous <spec>)
   (<spec> ^is.a NPSpecifier
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SpecProps2Noun
        ^span 3
        ^lexicals 0
        ^noun <noun>
        ^props2 <props2>
        ^spec <spec>
        ^previous <previous>
        ^debug-info (concat |Match a SpecProps2Noun construction, combination 0.|))
}

#   Apply the operator for the SpecProps2Noun construction
sp {comprehend-word*apply*match-construction*SpecProps2Noun
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SpecProps2Noun
        ^spec <spec>
        ^props2 <props2>
        ^noun <noun>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SpecProps2Noun
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of SpecifierNP
              ^constituents <constituents>
              ^spec <spec>
              ^props2 <props2>
              ^noun <noun>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SpecProps2Noun)
   (<constituents> ^spec <spec>
                   ^props2 <props2>
                   ^noun <noun>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SpecProps2Noun construction.|))
}

#   SpecProps2Noun self.m.category <--> noun.m constraint
sp {comprehend-word*SpecProps2Noun-constraint*self-m-category*UNIFY*noun-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecProps2Noun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   SpecProps2Noun self.m.givenness <--> spec.m constraint
sp {comprehend-word*SpecProps2Noun-constraint*self-m-givenness*UNIFY*spec-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecProps2Noun
          ^m <l-slot1>
          ^spec <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   SpecProps2Noun self.m.modifiers <--> props2.m constraint
sp {comprehend-word*SpecProps2Noun-constraint*self-m-modifiers*UNIFY*props2-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SpecProps2Noun
          ^m <l-slot1>
          ^props2 <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   BareSpecifier construction
sp {comprehend-word*generalize-cxn*BareSpecifier*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of BareSpecifier
          ^is <a>)
   (<a> -^a BareSpecifier)
-->
   (<a> ^a BareSpecifier)
   (<cxn> ^subcase-of BareSpecifier -
          ^subcase-of RefExpr)
}

#   Propose an operator for the Properties3 construction
sp {comprehend-word*propose*match-construction*Properties3
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <next>)
   (<next> ^is.a Property
           ^previous <first2>)
   (<first2> ^is.a Properties2
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Properties3
        ^span 2
        ^lexicals 0
        ^next <next>
        ^first2 <first2>
        ^previous <previous>
        ^debug-info (concat |Match a Properties3 construction, combination 0.|))
}

#   Apply the operator for the Properties3 construction
sp {comprehend-word*apply*match-construction*Properties3
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name Properties3
        ^first2 <first2>
        ^next <next>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name Properties3
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^first2 <first2>
              ^next <next>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a Properties3)
   (<constituents> ^first2 <first2>
                   ^next <next>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a Properties3 construction.|))
}

#   Propose an operator for the Properties2 construction
sp {comprehend-word*propose*match-construction*Properties2
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <next>)
   (<next> ^is.a Property
           ^previous <first>)
   (<first> ^is.a Property
            ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Properties2
        ^span 2
        ^lexicals 0
        ^next <next>
        ^first <first>
        ^previous <previous>
        ^debug-info (concat |Match a Properties2 construction, combination 0.|))
}

#   Apply the operator for the Properties2 construction
sp {comprehend-word*apply*match-construction*Properties2
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name Properties2
        ^first <first>
        ^next <next>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name Properties2
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^first <first>
              ^next <next>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a Properties2)
   (<constituents> ^first <first>
                   ^next <next>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a Properties2 construction.|))
}

#   Properties2 self.m <--> first.m constraint
sp {comprehend-word*Properties2-constraint*self-m*UNIFY*first-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Properties2
          ^m { <target> <> <value> }
          ^first <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   Properties2 self.m.next <--> next.m constraint
sp {comprehend-word*Properties2-constraint*self-m-next*UNIFY*next-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Properties2
          ^m <l-slot1>
          ^next <r-slot1>)
   (<l-slot1> ^next { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^next <target> -
              ^next <value>)
}

#   Propose an operator for the RefExprRelClause construction
sp {comprehend-word*propose*match-construction*RefExprRelClause
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <clause>)
   (<clause> ^is.a RelativeClause
             ^previous <subject>)
   (<subject> ^is.a RefExpr
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefExprRelClause
        ^span 2
        ^lexicals 0
        ^clause <clause>
        ^subject <subject>
        ^previous <previous>
        ^debug-info (concat |Match a RefExprRelClause construction, combination 0.|))
}

#   Apply the operator for the RefExprRelClause construction
sp {comprehend-word*apply*match-construction*RefExprRelClause
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefExprRelClause
        ^subject <subject>
        ^clause <clause>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefExprRelClause
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RefExpr
              ^constituents <constituents>
              ^subject <subject>
              ^clause <clause>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RefExprRelClause)
   (<constituents> ^subject <subject>
                   ^clause <clause>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefExprRelClause construction.|))
}

#   RefExprRelClause self.m.givenness <--> subject.m.givenness constraint
sp {comprehend-word*RefExprRelClause-constraint*self-m-givenness*UNIFY*subject-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprRelClause
          ^m <l-slot1>
          ^subject <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   RefExprRelClause self.m.referent <--> clause.m.referent constraint
sp {comprehend-word*RefExprRelClause-constraint*self-m-referent*UNIFY*clause-m-referent
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprRelClause
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^referent { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^referent <value>)
-->
   (<l-slot1> ^referent <target> -
              ^referent <value>)
}

#   RefExprRelClause self.m.relation <--> clause.m.relation constraint
sp {comprehend-word*RefExprRelClause-constraint*self-m-relation*UNIFY*clause-m-relation
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprRelClause
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^relation <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   RefExprRelClause self.m.modifiers <--> clause.m.modifiers constraint
sp {comprehend-word*RefExprRelClause-constraint*self-m-modifiers*UNIFY*clause-m-modifiers
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefExprRelClause
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^modifiers <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   RelativeClause construction
sp {comprehend-word*generalize-cxn*RelativeClause*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of RelativeClause
          ^is <a>)
   (<a> -^a RelativeClause)
-->
   (<a> ^a RelativeClause)
   (<cxn> ^subcase-of RelativeClause -)
}

#   Propose an operator for the RelativeClauseProperty construction
sp {comprehend-word*propose*match-construction*RelativeClauseProperty
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prop>)
   (<prop> ^is.a Property
           ^previous <head>)
   (<head> ^is.a HeadRelativeClause
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RelativeClauseProperty
        ^span 2
        ^lexicals 0
        ^prop <prop>
        ^head <head>
        ^previous <previous>
        ^debug-info (concat |Match a RelativeClauseProperty construction, combination 0.|))
}

#   Apply the operator for the RelativeClauseProperty construction
sp {comprehend-word*apply*match-construction*RelativeClauseProperty
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RelativeClauseProperty
        ^head <head>
        ^prop <prop>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RelativeClauseProperty
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RelativeClause
              ^constituents <constituents>
              ^head <head>
              ^prop <prop>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RelativeClauseProperty)
   (<constituents> ^head <head>
                   ^prop <prop>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RelativeClauseProperty construction.|))
}

#   RelativeClauseProperty self.m.category <--> head.m.category constraint
sp {comprehend-word*RelativeClauseProperty-constraint*self-m-category*UNIFY*head-m-category
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClauseProperty
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^category <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   RelativeClauseProperty self.m.givenness <--> head.m.givenness constraint
sp {comprehend-word*RelativeClauseProperty-constraint*self-m-givenness*UNIFY*head-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClauseProperty
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   RelativeClauseProperty self.m.referent <--> head.m.referent constraint
sp {comprehend-word*RelativeClauseProperty-constraint*self-m-referent*UNIFY*head-m-referent
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClauseProperty
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^referent { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^referent <value>)
-->
   (<l-slot1> ^referent <target> -
              ^referent <value>)
}

#   RelativeClauseProperty self.m.modifiers <--> prop.m constraint
sp {comprehend-word*RelativeClauseProperty-constraint*self-m-modifiers*UNIFY*prop-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClauseProperty
          ^m <l-slot1>
          ^prop <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   Propose an operator for the RelativeClausePrepPhrase construction
sp {comprehend-word*propose*match-construction*RelativeClausePrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prepPhrase>)
   (<prepPhrase> ^is.a PrepPhrase
                 ^previous <head>)
   (<head> ^is.a HeadRelativeClause
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RelativeClausePrepPhrase
        ^span 2
        ^lexicals 0
        ^prepPhrase <prepPhrase>
        ^head <head>
        ^previous <previous>
        ^debug-info (concat |Match a RelativeClausePrepPhrase construction, combination 0.|))
}

#   Apply the operator for the RelativeClausePrepPhrase construction
sp {comprehend-word*apply*match-construction*RelativeClausePrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RelativeClausePrepPhrase
        ^head <head>
        ^prepPhrase <prepPhrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RelativeClausePrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RelativeClause
              ^constituents <constituents>
              ^head <head>
              ^prepPhrase <prepPhrase>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RelativeClausePrepPhrase)
   (<constituents> ^head <head>
                   ^prepPhrase <prepPhrase>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RelativeClausePrepPhrase construction.|))
}

#   RelativeClausePrepPhrase self.m.category <--> head.m.category constraint
sp {comprehend-word*RelativeClausePrepPhrase-constraint*self-m-category*UNIFY*head-m-category
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClausePrepPhrase
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^category <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   RelativeClausePrepPhrase self.m.givenness <--> head.m.givenness constraint
sp {comprehend-word*RelativeClausePrepPhrase-constraint*self-m-givenness*UNIFY*head-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClausePrepPhrase
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   RelativeClausePrepPhrase self.m.modifiers <--> head.m.modifiers constraint
sp {comprehend-word*RelativeClausePrepPhrase-constraint*self-m-modifiers*UNIFY*head-m-modifiers
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClausePrepPhrase
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^modifiers { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^modifiers <value>)
-->
   (<l-slot1> ^modifiers <target> -
              ^modifiers <value>)
}

#   RelativeClausePrepPhrase self.m.referent <--> head.m.referent constraint
sp {comprehend-word*RelativeClausePrepPhrase-constraint*self-m-referent*UNIFY*head-m-referent
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClausePrepPhrase
          ^m <l-slot1>
          ^head <r-slot1>)
   (<l-slot1> ^referent { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^referent <value>)
-->
   (<l-slot1> ^referent <target> -
              ^referent <value>)
}

#   RelativeClausePrepPhrase self.m.relation <--> prepPhrase.m constraint
sp {comprehend-word*RelativeClausePrepPhrase-constraint*self-m-relation*UNIFY*prepphrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RelativeClausePrepPhrase
          ^m <l-slot1>
          ^prepPhrase <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   Propose an operator for the HeadRelativeClause construction
sp {comprehend-word*propose*match-construction*HeadRelativeClause
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <pro>)
   (<pro> ^is.a RelativePronoun
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name HeadRelativeClause
        ^span 2
        ^lexicals 0
        ^tobe <tobe>
        ^pro <pro>
        ^previous <previous>
        ^debug-info (concat |Match a HeadRelativeClause construction, combination 0.|))
}

#   Apply the operator for the HeadRelativeClause construction
sp {comprehend-word*apply*match-construction*HeadRelativeClause
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name HeadRelativeClause
        ^pro <pro>
        ^tobe <tobe>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name HeadRelativeClause
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^pro <pro>
              ^tobe <tobe>
              ^previous <previous>)
   (<a> ^a HeadRelativeClause)
   (<constituents> ^pro <pro>
                   ^tobe <tobe>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a HeadRelativeClause construction.|))
}

#   HeadRelativeClause self.m <--> pro.m constraint
sp {comprehend-word*HeadRelativeClause-constraint*self-m*UNIFY*pro-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a HeadRelativeClause
          ^m { <target> <> <value> }
          ^pro <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   Propose an operator for the PropertyDefinitionSentence construction
sp {comprehend-word*propose*match-construction*PropertyDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prop>)
   (<prop> ^is.a PropertySet
           ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <word>)
   (<word> ^is.a UNKNOWN-WORD
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertyDefinitionSentence
        ^span 3
        ^lexicals 1
        ^prop <prop>
        ^tobe <tobe>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a PropertyDefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the PropertyDefinitionSentence construction
sp {comprehend-word*apply*match-construction*PropertyDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertyDefinitionSentence
        ^word <word>
        ^tobe <tobe>
        ^prop <prop>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertyDefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^word <word>
              ^tobe <tobe>
              ^prop <prop>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a PropertyDefinitionSentence)
   (<constituents> ^word <word>
                   ^tobe <tobe>
                   ^prop <prop>)
   (<e-meaning> ^schema PropertyDefinition
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertyDefinitionSentence construction.|))
}

#   PropertyDefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*PropertyDefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertyDefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   PropertyDefinitionSentence self.m.class <--> prop.m constraint
sp {comprehend-word*PropertyDefinitionSentence-constraint*self-m-class*UNIFY*prop-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertyDefinitionSentence
          ^m <l-slot1>
          ^prop <r-slot1>)
   (<l-slot1> ^class { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^class <target> -
              ^class <value>)
}

#   Propose an operator for the PropertyRedefinitionSentence construction
sp {comprehend-word*propose*match-construction*PropertyRedefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prop>)
   (<prop> ^is.a PropertySet
           ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <word>)
   (<word> ^is.a Property
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertyRedefinitionSentence
        ^span 3
        ^lexicals 0
        ^prop <prop>
        ^tobe <tobe>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a PropertyRedefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the PropertyRedefinitionSentence construction
sp {comprehend-word*apply*match-construction*PropertyRedefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertyRedefinitionSentence
        ^word <word>
        ^tobe <tobe>
        ^prop <prop>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertyRedefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^word <word>
              ^tobe <tobe>
              ^prop <prop>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a PropertyRedefinitionSentence)
   (<constituents> ^word <word>
                   ^tobe <tobe>
                   ^prop <prop>)
   (<e-meaning> ^schema PropertyRedefinition
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertyRedefinitionSentence construction.|))
}

#   PropertyRedefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*PropertyRedefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertyRedefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   PropertyRedefinitionSentence self.m.old <--> word.m constraint
sp {comprehend-word*PropertyRedefinitionSentence-constraint*self-m-old*UNIFY*word-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertyRedefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^old { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^old <target> -
              ^old <value>)
}

#   PropertyRedefinitionSentence self.m.class <--> prop.m constraint
sp {comprehend-word*PropertyRedefinitionSentence-constraint*self-m-class*UNIFY*prop-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertyRedefinitionSentence
          ^m <l-slot1>
          ^prop <r-slot1>)
   (<l-slot1> ^class { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^class <target> -
              ^class <value>)
}

#   PropertySet construction
sp {comprehend-word*generalize-cxn*PropertySet*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of PropertySet
          ^is <a>)
   (<a> -^a PropertySet)
-->
   (<a> ^a PropertySet)
   (<cxn> ^subcase-of PropertySet -)
}

#   Propose an operator for the Property1Set construction, combination 0
sp {comprehend-word*propose*match-construction*Property1Set*0
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a PropertyClassName
            ^previous <previous>)
   (<previous> -^is.a Determiner
               -^is.a Property)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Property1Set
        ^span 1
        ^lexicals 0
        ^class <class>
        ^adj nil
        ^det nil
        ^previous <previous>
        ^debug-info (concat |Match a Property1Set construction, combination 0.|))
}

#   Propose an operator for the Property1Set construction, combination 1
sp {comprehend-word*propose*match-construction*Property1Set*1
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a PropertyClassName
            ^previous <adj>)
   (<adj> ^is.a Property
          ^previous <previous>)
   (<previous> -^is.a Determiner)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Property1Set
        ^span 2
        ^lexicals 0
        ^class <class>
        ^adj <adj>
        ^det nil
        ^previous <previous>
        ^debug-info (concat |Match a Property1Set construction, combination 1.|))
}

#   Propose an operator for the Property1Set construction, combination 2
sp {comprehend-word*propose*match-construction*Property1Set*2
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a PropertyClassName
            ^previous <det>)
   (<det> ^is.a Determiner
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Property1Set
        ^span 2
        ^lexicals 0
        ^class <class>
        ^adj nil
        ^det <det>
        ^previous <previous>
        ^debug-info (concat |Match a Property1Set construction, combination 2.|))
}

#   Propose an operator for the Property1Set construction, combination 3
sp {comprehend-word*propose*match-construction*Property1Set*3
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a PropertyClassName
            ^previous <adj>)
   (<adj> ^is.a Property
          ^previous <det>)
   (<det> ^is.a Determiner
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Property1Set
        ^span 3
        ^lexicals 0
        ^class <class>
        ^adj <adj>
        ^det <det>
        ^previous <previous>
        ^debug-info (concat |Match a Property1Set construction, combination 3.|))
}

#   Apply the operator for the Property1Set construction
sp {comprehend-word*apply*match-construction*Property1Set
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name Property1Set
        ^det <det>
        ^adj <adj>
        ^class <class>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name Property1Set
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of PropertySet
              ^constituents <constituents>
              ^det <det>
              ^adj <adj>
              ^class <class>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a Property1Set)
   (<constituents> ^det <det>
                   ^adj <adj>
                   ^class <class>)
   (<e-meaning> ^schema PropertySetDescriptor
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a Property1Set construction.|))
}

#   Property1Set self.m.givenness <--> det.m.givenness constraint
sp {comprehend-word*Property1Set-constraint*self-m-givenness*UNIFY*det-m-givenness
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Property1Set
          ^m <l-slot1>
          ^det <r-slot1>)
   (<l-slot1> ^givenness { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^givenness <value>)
-->
   (<l-slot1> ^givenness <target> -
              ^givenness <value>)
}

#   Property1Set self.m.property <--> adj.m constraint
sp {comprehend-word*Property1Set-constraint*self-m-property*UNIFY*adj-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Property1Set
          ^m <l-slot1>
          ^adj <r-slot1>)
   (<l-slot1> ^property { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^property <target> -
              ^property <value>)
}

#   Property1Set self.m.predicate <--> class.m.predicate constraint
sp {comprehend-word*Property1Set-constraint*self-m-predicate*UNIFY*class-m-predicate
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Property1Set
          ^m <l-slot1>
          ^class <r-slot1>)
   (<l-slot1> ^predicate { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^predicate <value>)
-->
   (<l-slot1> ^predicate <target> -
              ^predicate <value>)
}

#   DefiniteNP construction
sp {comprehend-word*generalize-cxn*DefiniteNP*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of DefiniteNP
          ^is <a>)
   (<a> -^a DefiniteNP)
-->
   (<a> ^a DefiniteNP)
   (<cxn> ^subcase-of DefiniteNP -
          ^subcase-of RefExpr)
}

#   Propose an operator for the THE-Mods-Noun construction
sp {comprehend-word*propose*match-construction*THE-Mods-Noun
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <noun>)
   (<noun> ^is.a CommonNoun
           ^previous <mods>)
   (<mods> ^is.a ModifierList
           ^previous <det>)
   (<det> ^is.a THE
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name THE-Mods-Noun
        ^span 3
        ^lexicals 1
        ^noun <noun>
        ^mods <mods>
        ^det <det>
        ^previous <previous>
        ^debug-info (concat |Match a THE-Mods-Noun construction, combination 0.|))
}

#   Apply the operator for the THE-Mods-Noun construction
sp {comprehend-word*apply*match-construction*THE-Mods-Noun
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name THE-Mods-Noun
        ^det <det>
        ^mods <mods>
        ^noun <noun>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name THE-Mods-Noun
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of DefiniteNP
              ^constituents <constituents>
              ^det <det>
              ^mods <mods>
              ^noun <noun>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a THE-Mods-Noun)
   (<constituents> ^det <det>
                   ^mods <mods>
                   ^noun <noun>)
   (<e-meaning> ^schema RefDesc
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a THE-Mods-Noun construction.|))
}

#   THE-Mods-Noun self.m.category <--> noun.m constraint
sp {comprehend-word*THE-Mods-Noun-constraint*self-m-category*UNIFY*noun-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a THE-Mods-Noun
          ^m <l-slot1>
          ^noun <r-slot1>)
   (<l-slot1> ^category { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^category <target> -
              ^category <value>)
}

#   THE-Mods-Noun self.m.givenness <-- definite constraint
sp {comprehend-word*THE-Mods-Noun-constraint*self-m-givenness*ASSIGN*definite
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a THE-Mods-Noun
          ^m <l-slot1>
          ^definite <value>)
   (<l-slot1> ^givenness { <target> <> <value> })
-->
   (<l-slot1> ^givenness <target> -
              ^givenness |definite|)
}

#   Propose an operator for the ModifierList construction, combination 0
sp {comprehend-word*propose*match-construction*ModifierList*0
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <next>)
   (<next> ^is.a Modifier
           ^previous <previous>)
   (<previous> -^is.a ModifierList)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ModifierList
        ^span 1
        ^lexicals 0
        ^next <next>
        ^list nil
        ^previous <previous>
        ^debug-info (concat |Match a ModifierList construction, combination 0.|))
}

#   Propose an operator for the ModifierList construction, combination 1
sp {comprehend-word*propose*match-construction*ModifierList*1
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <next>)
   (<next> ^is.a Modifier
           ^previous <list>)
   (<list> ^is.a ModifierList
           ^previous <previous>)
   (<previous> -^is.a ModifierList)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ModifierList
        ^span 2
        ^lexicals 0
        ^next <next>
        ^list <list>
        ^previous <previous>
        ^debug-info (concat |Match a ModifierList construction, combination 1.|))
}

#   Apply the operator for the ModifierList construction
sp {comprehend-word*apply*match-construction*ModifierList
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ModifierList
        ^list <list>
        ^next <next>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ModifierList
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^list <list>
              ^next <next>
              ^previous <previous>)
   (<a> ^a ModifierList)
   (<constituents> ^list <list>
                   ^next <next>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ModifierList construction.|))
}

