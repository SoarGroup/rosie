#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-arg-structs.ecg'.

#   Propose an operator for the DiTransitiveCommand construction
sp {comprehend-word*propose*match-construction*DiTransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <theme>)
   (<theme> ^is.a RefExpr
            ^previous <command>)
   (<command> ^is.a TransitiveCommand
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DiTransitiveCommand
        ^span 2
        ^lexicals 0
        ^theme <theme>
        ^command <command>
        ^previous <previous>
        ^debug-info (concat |Match a DiTransitiveCommand construction, combination 0.|))
}

#   Apply the operator for the DiTransitiveCommand construction
sp {comprehend-word*apply*match-construction*DiTransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DiTransitiveCommand
        ^command <command>
        ^theme <theme>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DiTransitiveCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^command <command>
              ^theme <theme>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a DiTransitiveCommand)
   (<constituents> ^command <command>
                   ^theme <theme>)
   (<e-meaning> ^schema DoTransfer
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DiTransitiveCommand construction.|))
}

#   DiTransitiveCommand self.m.action <--> command.verb.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-action*UNIFY*command-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   DiTransitiveCommand self.m.object <--> command.object.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-object*UNIFY*command-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   DiTransitiveCommand self.m.object2 <--> theme.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-object2*UNIFY*theme-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^theme <r-slot1>)
   (<l-slot1> ^object2 { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object2 <target> -
              ^object2 <value>)
}

#   RememberAasB construction
sp {comprehend-word*generalize-cxn*RememberAasB*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of RememberAasB
          ^is <a>)
   (<a> -^a RememberAasB)
-->
   (<a> ^a RememberAasB)
   (<cxn> ^subcase-of RememberAasB -
          ^subcase-of Imperative)
}

#   Propose an operator for the RememberRefExprasB construction
sp {comprehend-word*propose*match-construction*RememberRefExprasB
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <target>)
   (<target> ^is.a RefExpr
             ^previous <connector>)
   (<connector> ^is.a AS
                ^previous <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a REMEMBER
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RememberRefExprasB
        ^span 4
        ^lexicals 2
        ^target <target>
        ^connector <connector>
        ^object <object>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a RememberRefExprasB construction, combination 0.|))
}

#   Apply the operator for the RememberRefExprasB construction
sp {comprehend-word*apply*match-construction*RememberRefExprasB
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RememberRefExprasB
        ^verb <verb>
        ^object <object>
        ^connector <connector>
        ^target <target>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RememberRefExprasB
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RememberAasB
              ^constituents <constituents>
              ^verb <verb>
              ^object <object>
              ^connector <connector>
              ^target <target>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RememberRefExprasB)
   (<constituents> ^verb <verb>
                   ^object <object>
                   ^connector <connector>
                   ^target <target>)
   (<e-meaning> ^schema DoTransfer
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RememberRefExprasB construction.|))
}

#   RememberRefExprasB self.m.action <--> verb.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   RememberRefExprasB self.m.object <--> object.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   RememberRefExprasB self.m.object2 <--> target.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-object2*UNIFY*target-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^target <r-slot1>)
   (<l-slot1> ^object2 { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object2 <target> -
              ^object2 <value>)
}

#   Propose an operator for the ActionForTimePeriod construction
sp {comprehend-word*propose*match-construction*ActionForTimePeriod
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <end>)
   (<end> ^is.a NumberOfUnits
          ^previous <for>)
   (<for> ^is.a FOR
          ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ActionForTimePeriod
        ^span 3
        ^lexicals 1
        ^end <end>
        ^for <for>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a ActionForTimePeriod construction, combination 0.|))
}

#   Apply the operator for the ActionForTimePeriod construction
sp {comprehend-word*apply*match-construction*ActionForTimePeriod
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ActionForTimePeriod
        ^verb <verb>
        ^for <for>
        ^end <end>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ActionForTimePeriod
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^for <for>
              ^end <end>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ActionForTimePeriod)
   (<constituents> ^verb <verb>
                   ^for <for>
                   ^end <end>)
   (<e-meaning> ^schema ActionForTime
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ActionForTimePeriod construction.|))
}

#   ActionForTimePeriod self.m.action <--> verb.m constraint
sp {comprehend-word*ActionForTimePeriod-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActionForTimePeriod
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   ActionForTimePeriod self.m.time <--> end.m constraint
sp {comprehend-word*ActionForTimePeriod-constraint*self-m-time*UNIFY*end-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActionForTimePeriod
          ^m <l-slot1>
          ^end <r-slot1>)
   (<l-slot1> ^time { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^time <target> -
              ^time <value>)
}

#   Propose an operator for the RosieCommand construction
sp {comprehend-word*propose*match-construction*RosieCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <rosie>)
   (<rosie> ^is.a ROSIE
            ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RosieCommand
        ^span 3
        ^lexicals 1
        ^object <object>
        ^verb <verb>
        ^rosie <rosie>
        ^previous <previous>
        ^debug-info (concat |Match a RosieCommand construction, combination 0.|))
}

#   Apply the operator for the RosieCommand construction
sp {comprehend-word*apply*match-construction*RosieCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RosieCommand
        ^rosie <rosie>
        ^verb <verb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RosieCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^rosie <rosie>
              ^verb <verb>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RosieCommand)
   (<constituents> ^rosie <rosie>
                   ^verb <verb>
                   ^object <object>)
   (<e-meaning> ^schema ActOnIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RosieCommand construction.|))
}

#   RosieCommand self.m.action <--> verb.m constraint
sp {comprehend-word*RosieCommand-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RosieCommand
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   RosieCommand self.m.object <--> object.m constraint
sp {comprehend-word*RosieCommand-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RosieCommand
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the SubjectVerb construction
sp {comprehend-word*propose*match-construction*SubjectVerb
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <subject>)
   (<subject> ^is.a RefExpr
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerb
        ^span 2
        ^lexicals 0
        ^verb <verb>
        ^subject <subject>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerb construction, combination 0.|))
}

#   Apply the operator for the SubjectVerb construction
sp {comprehend-word*apply*match-construction*SubjectVerb
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerb
        ^subject <subject>
        ^verb <verb>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerb
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^subject <subject>
              ^verb <verb>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SubjectVerb)
   (<constituents> ^subject <subject>
                   ^verb <verb>)
   (<e-meaning> ^schema IntransitiveAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerb construction.|))
}

#   SubjectVerb self.m.subject <--> subject.m constraint
sp {comprehend-word*SubjectVerb-constraint*self-m-subject*UNIFY*subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerb
          ^m <l-slot1>
          ^subject <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerb self.m.verb <--> verb.m constraint
sp {comprehend-word*SubjectVerb-constraint*self-m-verb*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerb
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   Propose an operator for the SubjectVerbObject construction
sp {comprehend-word*propose*match-construction*SubjectVerbObject
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <subjectVerb>)
   (<subjectVerb> ^is.a SubjectVerb
                  ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerbObject
        ^span 2
        ^lexicals 0
        ^object <object>
        ^subjectVerb <subjectVerb>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerbObject construction, combination 0.|))
}

#   Apply the operator for the SubjectVerbObject construction
sp {comprehend-word*apply*match-construction*SubjectVerbObject
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerbObject
        ^subjectVerb <subjectVerb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerbObject
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^subjectVerb <subjectVerb>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SubjectVerbObject)
   (<constituents> ^subjectVerb <subjectVerb>
                   ^object <object>)
   (<e-meaning> ^schema TransitiveAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerbObject construction.|))
}

#   SubjectVerbObject self.m.subject <--> subjectVerb.subject.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-subject*UNIFY*subjectverb-subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^subjectVerb <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^subject <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerbObject self.m.verb <--> subjectVerb.verb.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-verb*UNIFY*subjectverb-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^subjectVerb <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   SubjectVerbObject self.m.object <--> object.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the SubjectVerbObjectPP construction
sp {comprehend-word*propose*match-construction*SubjectVerbObjectPP
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prepPhrase>)
   (<prepPhrase> ^is.a PrepPhrase
                 ^previous <clause>)
   (<clause> ^is.a SubjectVerbObject
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerbObjectPP
        ^span 2
        ^lexicals 0
        ^prepPhrase <prepPhrase>
        ^clause <clause>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerbObjectPP construction, combination 0.|))
}

#   Apply the operator for the SubjectVerbObjectPP construction
sp {comprehend-word*apply*match-construction*SubjectVerbObjectPP
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerbObjectPP
        ^clause <clause>
        ^prepPhrase <prepPhrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerbObjectPP
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^clause <clause>
              ^prepPhrase <prepPhrase>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SubjectVerbObjectPP)
   (<constituents> ^clause <clause>
                   ^prepPhrase <prepPhrase>)
   (<e-meaning> ^schema TransitiveAssertionPrepPhrase
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerbObjectPP construction.|))
}

#   SubjectVerbObjectPP self.m.subject <--> clause.subjectVerb.subject.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-subject*UNIFY*clause-subjectverb-subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^subjectVerb <r-slot2>)
   (<r-slot2> ^subject <r-slot3>)
   (<r-slot3> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerbObjectPP self.m.verb <--> clause.subjectVerb.verb.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-verb*UNIFY*clause-subjectverb-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^subjectVerb <r-slot2>)
   (<r-slot2> ^verb <r-slot3>)
   (<r-slot3> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   SubjectVerbObjectPP self.m.object <--> clause.object.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-object*UNIFY*clause-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   SubjectVerbObjectPP self.m.relation <--> prepPhrase.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-relation*UNIFY*prepphrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^prepPhrase <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   Propose an operator for the ConceptIsThat construction
sp {comprehend-word*propose*match-construction*ConceptIsThat
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <that>)
   (<that> ^is.a THAT-complementizer
           ^previous <toBe>)
   (<toBe> ^is.a FiniteToBe
           ^previous <idea>)
   (<idea> ^is.a RefExpr
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ConceptIsThat
        ^span 3
        ^lexicals 1
        ^that <that>
        ^toBe <toBe>
        ^idea <idea>
        ^previous <previous>
        ^debug-info (concat |Match a ConceptIsThat construction, combination 0.|))
}

#   Apply the operator for the ConceptIsThat construction
sp {comprehend-word*apply*match-construction*ConceptIsThat
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ConceptIsThat
        ^idea <idea>
        ^toBe <toBe>
        ^that <that>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ConceptIsThat
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^idea <idea>
              ^toBe <toBe>
              ^that <that>
              ^previous <previous>)
   (<a> ^a ConceptIsThat)
   (<constituents> ^idea <idea>
                   ^toBe <toBe>
                   ^that <that>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ConceptIsThat construction.|))
}

#   Propose an operator for the ConceptIsThatDeclarative construction
sp {comprehend-word*propose*match-construction*ConceptIsThatDeclarative
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <statement>)
   (<statement> ^is.a Declarative
                ^previous <firstPart>)
   (<firstPart> ^is.a ConceptIsThat
                ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ConceptIsThatDeclarative
        ^span 2
        ^lexicals 0
        ^statement <statement>
        ^firstPart <firstPart>
        ^previous <previous>
        ^debug-info (concat |Match a ConceptIsThatDeclarative construction, combination 0.|))
}

#   Apply the operator for the ConceptIsThatDeclarative construction
sp {comprehend-word*apply*match-construction*ConceptIsThatDeclarative
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ConceptIsThatDeclarative
        ^firstPart <firstPart>
        ^statement <statement>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ConceptIsThatDeclarative
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^firstPart <firstPart>
              ^statement <statement>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ConceptIsThatDeclarative)
   (<constituents> ^firstPart <firstPart>
                   ^statement <statement>)
   (<e-meaning> ^schema ConceptIsThatAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ConceptIsThatDeclarative construction.|))
}

#   ConceptIsThatDeclarative self.m.concept <--> firstPart.idea.m constraint
sp {comprehend-word*ConceptIsThatDeclarative-constraint*self-m-concept*UNIFY*firstpart-idea-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ConceptIsThatDeclarative
          ^m <l-slot1>
          ^firstPart <r-slot1>)
   (<l-slot1> ^concept { <target> <> <value> })
   (<r-slot1> ^idea <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^concept <target> -
              ^concept <value>)
}

#   ConceptIsThatDeclarative self.m.assertion <--> statement.m constraint
sp {comprehend-word*ConceptIsThatDeclarative-constraint*self-m-assertion*UNIFY*statement-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ConceptIsThatDeclarative
          ^m <l-slot1>
          ^statement <r-slot1>)
   (<l-slot1> ^assertion { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^assertion <target> -
              ^assertion <value>)
}

#   Propose an operator for the Negation construction
sp {comprehend-word*propose*match-construction*Negation
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <negator>)
   (<negator> ^is.a NOT
              ^previous <toBe>)
   (<toBe> ^is.a FiniteToBe
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Negation
        ^span 2
        ^lexicals 1
        ^negator <negator>
        ^toBe <toBe>
        ^previous <previous>
        ^debug-info (concat |Match a Negation construction, combination 0.|))
}

#   Apply the operator for the Negation construction
sp {comprehend-word*apply*match-construction*Negation
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name Negation
        ^toBe <toBe>
        ^negator <negator>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name Negation
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^toBe <toBe>
              ^negator <negator>
              ^previous <previous>)
   (<a> ^a Negation)
   (<constituents> ^toBe <toBe>
                   ^negator <negator>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a Negation construction.|))
}

#   Negation self.m <--> negator.m constraint
sp {comprehend-word*Negation-constraint*self-m*UNIFY*negator-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Negation
          ^m { <target> <> <value> }
          ^negator <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   Propose an operator for the RefIsNotPrepPhrase construction
sp {comprehend-word*propose*match-construction*RefIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a Negation
           ^previous <ref>)
   (<ref> ^is.a RefExpr
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefIsNotPrepPhrase
        ^span 3
        ^lexicals 0
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a RefIsNotPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the RefIsNotPrepPhrase construction
sp {comprehend-word*apply*match-construction*RefIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefIsNotPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefIsNotPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RefIsNotPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e-meaning> ^schema PrepPhraseAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefIsNotPrepPhrase construction.|))
}

#   RefIsNotPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   RefIsNotPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   RefIsNotPrepPhrase self.m.modifier <--> tobe.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-modifier*UNIFY*tobe-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^tobe <r-slot1>)
   (<l-slot1> ^modifier { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifier <target> -
              ^modifier <value>)
}

#   Propose an operator for the PropertySetIsPrepPhrase construction
sp {comprehend-word*propose*match-construction*PropertySetIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <ref>)
   (<ref> ^is.a PropertySet
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertySetIsPrepPhrase
        ^span 3
        ^lexicals 0
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a PropertySetIsPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the PropertySetIsPrepPhrase construction
sp {comprehend-word*apply*match-construction*PropertySetIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertySetIsPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertySetIsPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e-meaning>
              ^salient <salient>
              ^evokes <e-salient>
              ^previous <previous>)
   (<a> ^a PropertySetIsPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e-meaning> ^schema PrepPhraseAssertion
                ^target <meaning>)
   (<e-salient> ^schema Salient
                ^target <salient>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertySetIsPrepPhrase construction.|))
}

#   PropertySetIsPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*PropertySetIsPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   PropertySetIsPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*PropertySetIsPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   PropertySetIsPrepPhrase self.salient.reference <--> ref.m constraint
sp {comprehend-word*PropertySetIsPrepPhrase-constraint*self-salient-reference*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsPrepPhrase
          ^salient <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^reference { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^reference <target> -
              ^reference <value>)
}

#   Propose an operator for the PropertySetIsNotPrepPhrase construction
sp {comprehend-word*propose*match-construction*PropertySetIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a Negation
           ^previous <ref>)
   (<ref> ^is.a PropertySet
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertySetIsNotPrepPhrase
        ^span 3
        ^lexicals 0
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a PropertySetIsNotPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the PropertySetIsNotPrepPhrase construction
sp {comprehend-word*apply*match-construction*PropertySetIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertySetIsNotPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertySetIsNotPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e-meaning>
              ^salient <salient>
              ^evokes <e-salient>
              ^previous <previous>)
   (<a> ^a PropertySetIsNotPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e-meaning> ^schema PrepPhraseAssertion
                ^target <meaning>)
   (<e-salient> ^schema Salient
                ^target <salient>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertySetIsNotPrepPhrase construction.|))
}

#   PropertySetIsNotPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   PropertySetIsNotPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   PropertySetIsNotPrepPhrase self.m.modifier <--> tobe.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-modifier*UNIFY*tobe-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^tobe <r-slot1>)
   (<l-slot1> ^modifier { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifier <target> -
              ^modifier <value>)
}

#   PropertySetIsNotPrepPhrase self.salient.reference <--> ref.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-salient-reference*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^salient <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^reference { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^reference <target> -
              ^reference <value>)
}

#   Propose an operator for the AskQuestion construction
sp {comprehend-word*propose*match-construction*AskQuestion
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <question>)
   (<question> ^is.a Question
               ^previous <verb>)
   (<verb> ^is.a ASK
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name AskQuestion
        ^span 2
        ^lexicals 1
        ^question <question>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a AskQuestion construction, combination 0.|))
}

#   Apply the operator for the AskQuestion construction
sp {comprehend-word*apply*match-construction*AskQuestion
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name AskQuestion
        ^verb <verb>
        ^question <question>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name AskQuestion
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^question <question>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a AskQuestion)
   (<constituents> ^verb <verb>
                   ^question <question>)
   (<e-meaning> ^schema AskQuestionCommand
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a AskQuestion construction.|))
}

#   AskQuestion self.m.action <--> verb.m constraint
sp {comprehend-word*AskQuestion-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a AskQuestion
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   AskQuestion self.m.object <--> question.m constraint
sp {comprehend-word*AskQuestion-constraint*self-m-object*UNIFY*question-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a AskQuestion
          ^m <l-slot1>
          ^question <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the TransitiveVerbDefinitionSentence construction
sp {comprehend-word*propose*match-construction*TransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <word>)
   (<word> ^is.a UNKNOWN-WORD
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TransitiveVerbDefinitionSentence
        ^span 2
        ^lexicals 1
        ^object <object>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a TransitiveVerbDefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the TransitiveVerbDefinitionSentence construction
sp {comprehend-word*apply*match-construction*TransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TransitiveVerbDefinitionSentence
        ^word <word>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TransitiveVerbDefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^word <word>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TransitiveVerbDefinitionSentence)
   (<constituents> ^word <word>
                   ^object <object>)
   (<e-meaning> ^schema TransitiveVerbDefinition
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TransitiveVerbDefinitionSentence construction.|))
}

#   TransitiveVerbDefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*TransitiveVerbDefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   TransitiveVerbDefinitionSentence self.m.object <--> object.m constraint
sp {comprehend-word*TransitiveVerbDefinitionSentence-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the IntransitiveVerbDefinitionSentence construction
sp {comprehend-word*propose*match-construction*IntransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <location>)
   (<location> ^is.a PrepPhrase
               ^previous <word>)
   (<word> ^is.a UNKNOWN-WORD
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IntransitiveVerbDefinitionSentence
        ^span 2
        ^lexicals 1
        ^location <location>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a IntransitiveVerbDefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the IntransitiveVerbDefinitionSentence construction
sp {comprehend-word*apply*match-construction*IntransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IntransitiveVerbDefinitionSentence
        ^word <word>
        ^location <location>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IntransitiveVerbDefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^word <word>
              ^location <location>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a IntransitiveVerbDefinitionSentence)
   (<constituents> ^word <word>
                   ^location <location>)
   (<e-meaning> ^schema IntransitiveVerbDefinition
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IntransitiveVerbDefinitionSentence construction.|))
}

#   IntransitiveVerbDefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*IntransitiveVerbDefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IntransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   IntransitiveVerbDefinitionSentence self.m.location <--> location.m constraint
sp {comprehend-word*IntransitiveVerbDefinitionSentence-constraint*self-m-location*UNIFY*location-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IntransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^location <r-slot1>)
   (<l-slot1> ^location { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^location <target> -
              ^location <value>)
}

