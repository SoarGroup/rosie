#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-verbs.ecg'.

#   ASK construction
sp {comprehend-word*apply*lexical-access*ASK-ask
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |ask|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name ASK
          ^is <a>
          ^orth |ask|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a ASK)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   ASK self.m.class <-- @action constraint
sp {comprehend-word*ASK-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ASK
          ^orth |ask|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   ASK self.m.name <-- "ask1" constraint
sp {comprehend-word*ASK-constraint*self-m-name*ASSIGN*ask1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ASK
          ^orth |ask|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |ask1| })
-->
   (<l-slot1> ^name <target> -
              ^name |ask1|)
}

#   CHECK construction
sp {comprehend-word*apply*lexical-access*CHECK-check
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |check|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name CHECK
          ^is <a>
          ^orth |check|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a CHECK)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   CHECK self.m.class <-- @action constraint
sp {comprehend-word*CHECK-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CHECK
          ^orth |check|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   CHECK self.m.name <-- "check1" constraint
sp {comprehend-word*CHECK-constraint*self-m-name*ASSIGN*check1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CHECK
          ^orth |check|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |check1| })
-->
   (<l-slot1> ^name <target> -
              ^name |check1|)
}

#   CLEAN construction
sp {comprehend-word*apply*lexical-access*CLEAN-clean
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |clean|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name CLEAN
          ^is <a>
          ^orth |clean|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a CLEAN)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   CLEAN self.m.class <-- @action constraint
sp {comprehend-word*CLEAN-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CLEAN
          ^orth |clean|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   CLEAN self.m.name <-- "clean1" constraint
sp {comprehend-word*CLEAN-constraint*self-m-name*ASSIGN*clean1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CLEAN
          ^orth |clean|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |clean1| })
-->
   (<l-slot1> ^name <target> -
              ^name |clean1|)
}

#   CLOSE construction
sp {comprehend-word*apply*lexical-access*CLOSE-close
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |close|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name CLOSE
          ^is <a>
          ^orth |close|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a CLOSE)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   CLOSE self.m.class <-- @action constraint
sp {comprehend-word*CLOSE-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CLOSE
          ^orth |close|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   CLOSE self.m.name <-- "close1" constraint
sp {comprehend-word*CLOSE-constraint*self-m-name*ASSIGN*close1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CLOSE
          ^orth |close|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |close1| })
-->
   (<l-slot1> ^name <target> -
              ^name |close1|)
}

#   COOK construction
sp {comprehend-word*apply*lexical-access*COOK-cook
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |cook|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name COOK
          ^is <a>
          ^orth |cook|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a COOK)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   COOK self.m.class <-- @action constraint
sp {comprehend-word*COOK-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a COOK
          ^orth |cook|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   COOK self.m.name <-- "cook1" constraint
sp {comprehend-word*COOK-constraint*self-m-name*ASSIGN*cook1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a COOK
          ^orth |cook|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |cook1| })
-->
   (<l-slot1> ^name <target> -
              ^name |cook1|)
}

#   DISCARD construction
sp {comprehend-word*apply*lexical-access*DISCARD-discard
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |discard|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name DISCARD
          ^is <a>
          ^orth |discard|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a DISCARD)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   DISCARD self.m.class <-- @action constraint
sp {comprehend-word*DISCARD-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DISCARD
          ^orth |discard|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   DISCARD self.m.name <-- "discard1" constraint
sp {comprehend-word*DISCARD-constraint*self-m-name*ASSIGN*discard1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DISCARD
          ^orth |discard|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |discard1| })
-->
   (<l-slot1> ^name <target> -
              ^name |discard1|)
}

#   HEARD construction
sp {comprehend-word*apply*lexical-access*HEARD-heard
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |heard|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name HEARD
          ^is <a>
          ^orth |heard|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a HEARD)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   HEARD self.m.class <-- @action constraint
sp {comprehend-word*HEARD-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a HEARD
          ^orth |heard|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   HEARD self.m.name <-- "heard1" constraint
sp {comprehend-word*HEARD-constraint*self-m-name*ASSIGN*heard1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a HEARD
          ^orth |heard|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |heard1| })
-->
   (<l-slot1> ^name <target> -
              ^name |heard1|)
}

#   INTERROGATE construction
sp {comprehend-word*apply*lexical-access*INTERROGATE-interrogate
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |interrogate|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name INTERROGATE
          ^is <a>
          ^orth |interrogate|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a INTERROGATE)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   INTERROGATE self.m.class <-- @action constraint
sp {comprehend-word*INTERROGATE-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a INTERROGATE
          ^orth |interrogate|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   INTERROGATE self.m.name <-- "interrogate12" constraint
sp {comprehend-word*INTERROGATE-constraint*self-m-name*ASSIGN*interrogate12
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a INTERROGATE
          ^orth |interrogate|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |interrogate12| })
-->
   (<l-slot1> ^name <target> -
              ^name |interrogate12|)
}

#   OPEN construction
sp {comprehend-word*apply*lexical-access*OPEN-open
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |open|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name OPEN
          ^is <a>
          ^orth |open|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a OPEN)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   OPEN self.m.class <-- @action constraint
sp {comprehend-word*OPEN-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a OPEN
          ^orth |open|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   OPEN self.m.name <-- "open1" constraint
sp {comprehend-word*OPEN-constraint*self-m-name*ASSIGN*open1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a OPEN
          ^orth |open|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |open1| })
-->
   (<l-slot1> ^name <target> -
              ^name |open1|)
}

#   ORGANIZE construction
sp {comprehend-word*apply*lexical-access*ORGANIZE-organize
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |organize|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name ORGANIZE
          ^is <a>
          ^orth |organize|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a ORGANIZE)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   ORGANIZE self.m.class <-- @action constraint
sp {comprehend-word*ORGANIZE-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ORGANIZE
          ^orth |organize|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   ORGANIZE self.m.name <-- "organize1" constraint
sp {comprehend-word*ORGANIZE-constraint*self-m-name*ASSIGN*organize1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ORGANIZE
          ^orth |organize|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |organize1| })
-->
   (<l-slot1> ^name <target> -
              ^name |organize1|)
}

#   REMEMBER construction
sp {comprehend-word*apply*lexical-access*REMEMBER-remember
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |remember|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name REMEMBER
          ^is <a>
          ^orth |remember|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a REMEMBER)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   REMEMBER self.m.class <-- @action constraint
sp {comprehend-word*REMEMBER-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a REMEMBER
          ^orth |remember|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   REMEMBER self.m.name <-- "remember1" constraint
sp {comprehend-word*REMEMBER-constraint*self-m-name*ASSIGN*remember1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a REMEMBER
          ^orth |remember|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |remember1| })
-->
   (<l-slot1> ^name <target> -
              ^name |remember1|)
}

#   SAID construction
sp {comprehend-word*apply*lexical-access*SAID-said
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |said|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SAID
          ^is <a>
          ^orth |said|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a SAID)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   SAID self.m.class <-- @action constraint
sp {comprehend-word*SAID-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SAID
          ^orth |said|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   SAID self.m.name <-- "say1" constraint
sp {comprehend-word*SAID-constraint*self-m-name*ASSIGN*say1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SAID
          ^orth |said|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |say1| })
-->
   (<l-slot1> ^name <target> -
              ^name |say1|)
}

#   SAY construction
sp {comprehend-word*apply*lexical-access*SAY-say
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |say|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SAY
          ^is <a>
          ^orth |say|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a SAY)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   SAY self.m.class <-- @action constraint
sp {comprehend-word*SAY-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SAY
          ^orth |say|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   SAY self.m.name <-- "say1" constraint
sp {comprehend-word*SAY-constraint*self-m-name*ASSIGN*say1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SAY
          ^orth |say|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |say1| })
-->
   (<l-slot1> ^name <target> -
              ^name |say1|)
}

#   SERVE construction
sp {comprehend-word*apply*lexical-access*SERVE-serve
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |serve|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SERVE
          ^is <a>
          ^orth |serve|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a SERVE)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   SERVE self.m.class <-- @action constraint
sp {comprehend-word*SERVE-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SERVE
          ^orth |serve|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   SERVE self.m.name <-- "serve1" constraint
sp {comprehend-word*SERVE-constraint*self-m-name*ASSIGN*serve1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SERVE
          ^orth |serve|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |serve1| })
-->
   (<l-slot1> ^name <target> -
              ^name |serve1|)
}

#   SET construction
sp {comprehend-word*apply*lexical-access*SET-set
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |set|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SET
          ^is <a>
          ^orth |set|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a SET)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   SET self.m.class <-- @action constraint
sp {comprehend-word*SET-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SET
          ^orth |set|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   SET self.m.name <-- "set" constraint
sp {comprehend-word*SET-constraint*self-m-name*ASSIGN*set
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SET
          ^orth |set|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |set| })
-->
   (<l-slot1> ^name <target> -
              ^name |set|)
}

#   TELL construction
sp {comprehend-word*apply*lexical-access*TELL-tell
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |tell|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TELL
          ^is <a>
          ^orth |tell|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a TELL)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   TELL self.m.class <-- @action constraint
sp {comprehend-word*TELL-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TELL
          ^orth |tell|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   TELL self.m.name <-- "tell1" constraint
sp {comprehend-word*TELL-constraint*self-m-name*ASSIGN*tell1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TELL
          ^orth |tell|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |tell1| })
-->
   (<l-slot1> ^name <target> -
              ^name |tell1|)
}

#   Propose an operator for the ThrowAway construction
sp {comprehend-word*propose*match-construction*ThrowAway
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <away>)
   (<away> ^is.a AWAY
           ^previous <verb>)
   (<verb> ^is.a THROW
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ThrowAway
        ^span 2
        ^lexicals 2
        ^away <away>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a ThrowAway construction, combination 0.|))
}

#   Apply the operator for the ThrowAway construction
sp {comprehend-word*apply*match-construction*ThrowAway
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ThrowAway
        ^verb <verb>
        ^away <away>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ThrowAway
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of ActionVerb
              ^constituents <constituents>
              ^verb <verb>
              ^away <away>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ThrowAway)
   (<constituents> ^verb <verb>
                   ^away <away>)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ThrowAway construction.|))
}

#   ThrowAway self.m <--> verb.m constraint
sp {comprehend-word*ThrowAway-constraint*self-m*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ThrowAway
          ^m { <target> <> <value> }
          ^verb <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   THROW construction
sp {comprehend-word*apply*lexical-access*THROW-throw
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |throw|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name THROW
          ^is <a>
          ^orth |throw|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a THROW)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   THROW self.m.class <-- @action constraint
sp {comprehend-word*THROW-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a THROW
          ^orth |throw|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   THROW self.m.name <-- "throw1" constraint
sp {comprehend-word*THROW-constraint*self-m-name*ASSIGN*throw1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a THROW
          ^orth |throw|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |throw1| })
-->
   (<l-slot1> ^name <target> -
              ^name |throw1|)
}

#   AWAY construction
sp {comprehend-word*apply*lexical-access*AWAY-away
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |away|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name AWAY
          ^is <a>
          ^orth |away|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Particle
          ^first-lex nil)
   (<a> ^a AWAY)
}

#   AWAY self.m.id <-- "away1" constraint
sp {comprehend-word*AWAY-constraint*self-m-id*ASSIGN*away1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a AWAY
          ^orth |away|
          ^m <l-slot1>)
   (<l-slot1> ^id { <target> <> |away1| })
-->
   (<l-slot1> ^id <target> -
              ^id |away1|)
}

#   TurnOffVerb construction
sp {comprehend-word*apply*lexical-access*TurnOffVerb-turn-off
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |off|
           ^content <content2>)
   (<s> ^superstate.comprehension.lex-stack <previous1>)
   (<previous1> ^word.orth |turn|
                ^word.content <content1>
                ^previous <previous2>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TurnOffVerb
          ^is <a>
          ^orth |turn off|
          ^text (concat <content1> | | <content2>)
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex <previous1>
          ^evokes <e-meaning>)
   (<a> ^a TurnOffVerb)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   TurnOffVerb self.m.class <-- @action constraint
sp {comprehend-word*TurnOffVerb-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnOffVerb
          ^orth |turn off|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   TurnOffVerb self.m.name <-- "turn-off1" constraint
sp {comprehend-word*TurnOffVerb-constraint*self-m-name*ASSIGN*turn-off1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnOffVerb
          ^orth |turn off|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |turn-off1| })
-->
   (<l-slot1> ^name <target> -
              ^name |turn-off1|)
}

#   WAIT construction
sp {comprehend-word*apply*lexical-access*WAIT-wait
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |wait|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name WAIT
          ^is <a>
          ^orth |wait|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of ActionVerb
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a WAIT)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   WAIT self.m.class <-- @action constraint
sp {comprehend-word*WAIT-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WAIT
          ^orth |wait|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   WAIT self.m.name <-- "wait1" constraint
sp {comprehend-word*WAIT-constraint*self-m-name*ASSIGN*wait1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WAIT
          ^orth |wait|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |wait1| })
-->
   (<l-slot1> ^name <target> -
              ^name |wait1|)
}

