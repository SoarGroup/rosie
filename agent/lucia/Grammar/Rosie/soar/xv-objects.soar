#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-objects.ecg'.

#   Room schema
sp {comprehend-word*evoked-schema*Room*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Room
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Room
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Room)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value room1)
}

#   Room schema
sp {comprehend-word*evoked-schema*Room*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Room
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Room)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value room1)
}

#   Rosie schema
sp {comprehend-word*evoked-schema*Rosie*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Rosie
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Rosie
               ^is <a>
               ^name |rosie1|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Rosie)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value person)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value rosie)
}

#   Rosie schema
sp {comprehend-word*evoked-schema*Rosie*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Rosie
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^name |rosie1|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Rosie)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value person)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value rosie)
}

#   Bob schema
sp {comprehend-word*evoked-schema*Bob*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Bob
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name Bob
               ^is <a>
               ^name |Bob|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Bob)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<e2> ^schema KnownObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value person)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value bob1)
}

#   Bob schema
sp {comprehend-word*evoked-schema*Bob*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Bob
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^name |Bob|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Bob)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<e2> ^schema KnownObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value person)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value bob1)
}

#   Lights schema
sp {comprehend-word*evoked-schema*Lights*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Lights
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Lights
               ^is <a>
               ^name |lights1|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Lights)
   (<e1> ^schema KnownObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value conference-room-lights1)
}

#   Lights schema
sp {comprehend-word*evoked-schema*Lights*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Lights
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^name |lights1|
               ^constraint <c1>
               ^constraint <c2>
               ^constraint <c3>)
   (<a> ^a Lights)
   (<e1> ^schema KnownObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value false)
   (<c3> ^attr handle
         ^value conference-room-lights1)
}

#   Question schema
sp {comprehend-word*evoked-schema*Question*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Question
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Question
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Question)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value question)
}

#   Question schema
sp {comprehend-word*evoked-schema*Question*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Question
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Question)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value question)
}

#   Answer schema
sp {comprehend-word*evoked-schema*Answer*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Answer
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Answer
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Answer)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value answer1)
}

#   Answer schema
sp {comprehend-word*evoked-schema*Answer*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Answer
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Answer)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value answer1)
}

#   Response schema
sp {comprehend-word*evoked-schema*Response*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Response
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Response
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Response)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value response)
}

#   Response schema
sp {comprehend-word*evoked-schema*Response*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Response
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Response)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value response)
}

#   Message schema
sp {comprehend-word*evoked-schema*Message*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Message
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Message
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Message)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value message)
}

#   Message schema
sp {comprehend-word*evoked-schema*Message*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Message
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Message)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value message)
}

