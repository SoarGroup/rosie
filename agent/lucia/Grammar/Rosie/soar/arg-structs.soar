#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\arg-structs.ecg'.

#   Declarative construction
sp {comprehend-word*generalize-cxn*Declarative*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of Declarative
          ^is <a>
          ^m <meaning>)
   (<a> -^a Declarative)
-->
   (<a> ^a Declarative)
   (<cxn> ^subcase-of Declarative -
          ^subcase-of VerbWithArguments
          ^evokes <e-meaning>)
   (<e-meaning> ^schema Assertion
                ^target <meaning>)
}

#   Propose an operator for the RefIsProperty construction
sp {comprehend-word*propose*match-construction*RefIsProperty
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prop>)
   (<prop> ^is.a Property
           ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <ref>)
   (<ref> ^is.a RefExpr
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefIsProperty
        ^span 3
        ^lexicals 0
        ^prop <prop>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a RefIsProperty construction, combination 0.|))
}

#   Apply the operator for the RefIsProperty construction
sp {comprehend-word*apply*match-construction*RefIsProperty
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefIsProperty
        ^ref <ref>
        ^tobe <tobe>
        ^prop <prop>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefIsProperty
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^prop <prop>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a RefIsProperty)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^prop <prop>)
   (<e-meaning> ^schema PropertyApplication
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefIsProperty construction.|))
}

#   RefIsProperty self.m.property <--> prop.m constraint
sp {comprehend-word*RefIsProperty-constraint*self-m-property*UNIFY*prop-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsProperty
          ^m <l-slot1>
          ^prop <r-slot1>)
   (<l-slot1> ^property { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^property <target> -
              ^property <value>)
}

#   RefIsProperty self.m.target <--> ref.m constraint
sp {comprehend-word*RefIsProperty-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsProperty
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   Propose an operator for the RefIsPrepPhrase construction
sp {comprehend-word*propose*match-construction*RefIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <ref>)
   (<ref> ^is.a RefExpr
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefIsPrepPhrase
        ^span 3
        ^lexicals 0
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a RefIsPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the RefIsPrepPhrase construction
sp {comprehend-word*apply*match-construction*RefIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefIsPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefIsPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e-meaning>
              ^salient <salient>
              ^evokes <e-salient>
              ^previous <previous>)
   (<a> ^a RefIsPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e-meaning> ^schema PrepPhraseAssertion
                ^target <meaning>)
   (<e-salient> ^schema Salient
                ^target <salient>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefIsPrepPhrase construction.|))
}

#   RefIsPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*RefIsPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   RefIsPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*RefIsPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   RefIsPrepPhrase self.salient.reference <--> ref.m constraint
sp {comprehend-word*RefIsPrepPhrase-constraint*self-salient-reference*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsPrepPhrase
          ^salient <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^reference { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^reference <target> -
              ^reference <value>)
}

#   Propose an operator for the ThisIsAThat construction
sp {comprehend-word*propose*match-construction*ThisIsAThat
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <that>)
   (<that> ^is.a PropertySet
           ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <this>)
   (<this> ^is.a DeicticPronoun
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ThisIsAThat
        ^span 3
        ^lexicals 0
        ^that <that>
        ^tobe <tobe>
        ^this <this>
        ^previous <previous>
        ^debug-info (concat |Match a ThisIsAThat construction, combination 0.|))
}

#   Apply the operator for the ThisIsAThat construction
sp {comprehend-word*apply*match-construction*ThisIsAThat
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ThisIsAThat
        ^this <this>
        ^tobe <tobe>
        ^that <that>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ThisIsAThat
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^this <this>
              ^tobe <tobe>
              ^that <that>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ThisIsAThat)
   (<constituents> ^this <this>
                   ^tobe <tobe>
                   ^that <that>)
   (<e-meaning> ^schema ThisIsAThatAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ThisIsAThat construction.|))
}

#   ThisIsAThat self.m.this <--> this.m constraint
sp {comprehend-word*ThisIsAThat-constraint*self-m-this*UNIFY*this-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ThisIsAThat
          ^m <l-slot1>
          ^this <r-slot1>)
   (<l-slot1> ^this { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^this <target> -
              ^this <value>)
}

#   ThisIsAThat self.m.that <--> that.m constraint
sp {comprehend-word*ThisIsAThat-constraint*self-m-that*UNIFY*that-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ThisIsAThat
          ^m <l-slot1>
          ^that <r-slot1>)
   (<l-slot1> ^that { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^that <target> -
              ^that <value>)
}

#   Propose an operator for the ThisIsTheThat construction
sp {comprehend-word*propose*match-construction*ThisIsTheThat
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <that>)
   (<that> ^is.a RefExpr
           ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <this>)
   (<this> ^is.a DeicticPronoun
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ThisIsTheThat
        ^span 3
        ^lexicals 0
        ^that <that>
        ^tobe <tobe>
        ^this <this>
        ^previous <previous>
        ^debug-info (concat |Match a ThisIsTheThat construction, combination 0.|))
}

#   Apply the operator for the ThisIsTheThat construction
sp {comprehend-word*apply*match-construction*ThisIsTheThat
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ThisIsTheThat
        ^this <this>
        ^tobe <tobe>
        ^that <that>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ThisIsTheThat
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^this <this>
              ^tobe <tobe>
              ^that <that>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ThisIsTheThat)
   (<constituents> ^this <this>
                   ^tobe <tobe>
                   ^that <that>)
   (<e-meaning> ^schema ThisIsTheThatAssertion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ThisIsTheThat construction.|))
}

#   ThisIsTheThat self.m.this <--> this.m constraint
sp {comprehend-word*ThisIsTheThat-constraint*self-m-this*UNIFY*this-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ThisIsTheThat
          ^m <l-slot1>
          ^this <r-slot1>)
   (<l-slot1> ^this { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^this <target> -
              ^this <value>)
}

#   ThisIsTheThat self.m.that <--> that.m constraint
sp {comprehend-word*ThisIsTheThat-constraint*self-m-that*UNIFY*that-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ThisIsTheThat
          ^m <l-slot1>
          ^that <r-slot1>)
   (<l-slot1> ^that { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^that <target> -
              ^that <value>)
}

#   PrepPhrase construction
sp {comprehend-word*generalize-cxn*PrepPhrase*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of PrepPhrase
          ^is <a>)
   (<a> -^a PrepPhrase)
-->
   (<a> ^a PrepPhrase)
   (<cxn> ^subcase-of PrepPhrase -)
}

#   Propose an operator for the SimplePrepPhrase construction
sp {comprehend-word*propose*match-construction*SimplePrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <prep>)
   (<prep> ^is.a Preposition
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SimplePrepPhrase
        ^span 2
        ^lexicals 0
        ^object <object>
        ^prep <prep>
        ^previous <previous>
        ^debug-info (concat |Match a SimplePrepPhrase construction, combination 0.|))
}

#   Apply the operator for the SimplePrepPhrase construction
sp {comprehend-word*apply*match-construction*SimplePrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SimplePrepPhrase
        ^prep <prep>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SimplePrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of PrepPhrase
              ^constituents <constituents>
              ^prep <prep>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SimplePrepPhrase)
   (<constituents> ^prep <prep>
                   ^object <object>)
   (<e-meaning> ^schema PrepRelation
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SimplePrepPhrase construction.|))
}

#   SimplePrepPhrase self.m.prep <--> prep.m.name constraint
sp {comprehend-word*SimplePrepPhrase-constraint*self-m-prep*UNIFY*prep-m-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SimplePrepPhrase
          ^m <l-slot1>
          ^prep <r-slot1>)
   (<l-slot1> ^prep { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^name <value>)
-->
   (<l-slot1> ^prep <target> -
              ^prep <value>)
}

#   SimplePrepPhrase self.m.object <--> object.m constraint
sp {comprehend-word*SimplePrepPhrase-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SimplePrepPhrase
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the DirectionalPrepPhrase construction
sp {comprehend-word*propose*match-construction*DirectionalPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <prep>)
   (<prep> ^is.a DirectionalPreposition
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DirectionalPrepPhrase
        ^span 2
        ^lexicals 0
        ^object <object>
        ^prep <prep>
        ^previous <previous>
        ^debug-info (concat |Match a DirectionalPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the DirectionalPrepPhrase construction
sp {comprehend-word*apply*match-construction*DirectionalPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DirectionalPrepPhrase
        ^prep <prep>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DirectionalPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^prep <prep>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a DirectionalPrepPhrase)
   (<constituents> ^prep <prep>
                   ^object <object>)
   (<e-meaning> ^schema PrepRelation
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DirectionalPrepPhrase construction.|))
}

#   DirectionalPrepPhrase self.m.prep <--> prep.m.name constraint
sp {comprehend-word*DirectionalPrepPhrase-constraint*self-m-prep*UNIFY*prep-m-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DirectionalPrepPhrase
          ^m <l-slot1>
          ^prep <r-slot1>)
   (<l-slot1> ^prep { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^name <value>)
-->
   (<l-slot1> ^prep <target> -
              ^prep <value>)
}

#   DirectionalPrepPhrase self.m.object <--> object.m constraint
sp {comprehend-word*DirectionalPrepPhrase-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DirectionalPrepPhrase
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   VerbWithArguments construction
sp {comprehend-word*generalize-cxn*VerbWithArguments*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of VerbWithArguments
          ^is <a>)
   (<a> -^a VerbWithArguments)
-->
   (<a> ^a VerbWithArguments)
   (<cxn> ^subcase-of VerbWithArguments -)
}

#   Propose an operator for the ImperativeWithLocation construction
sp {comprehend-word*propose*match-construction*ImperativeWithLocation
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <location>)
   (<location> ^is.a PrepPhrase
               ^previous <command>)
   (<command> ^is.a Imperative
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ImperativeWithLocation
        ^span 2
        ^lexicals 0
        ^location <location>
        ^command <command>
        ^previous <previous>
        ^debug-info (concat |Match a ImperativeWithLocation construction, combination 0.|))
}

#   Apply the operator for the ImperativeWithLocation construction
sp {comprehend-word*apply*match-construction*ImperativeWithLocation
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ImperativeWithLocation
        ^command <command>
        ^location <location>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ImperativeWithLocation
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^command <command>
              ^location <location>
              ^evokes <e-meaning>
              ^salient <salient>
              ^evokes <e-salient>
              ^previous <previous>)
   (<a> ^a ImperativeWithLocation)
   (<constituents> ^command <command>
                   ^location <location>)
   (<e-meaning> ^schema Action
                ^target <meaning>)
   (<e-salient> ^schema Salient
                ^target <salient>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ImperativeWithLocation construction.|))
}

#   ImperativeWithLocation self.m.action <--> command.m constraint
sp {comprehend-word*ImperativeWithLocation-constraint*self-m-action*UNIFY*command-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ImperativeWithLocation
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   ImperativeWithLocation self.m.location <--> location.m constraint
sp {comprehend-word*ImperativeWithLocation-constraint*self-m-location*UNIFY*location-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ImperativeWithLocation
          ^m <l-slot1>
          ^location <r-slot1>)
   (<l-slot1> ^location { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^location <target> -
              ^location <value>)
}

#   ImperativeWithLocation self.m.object <--> command.object constraint
sp {comprehend-word*ImperativeWithLocation-constraint*self-m-object*UNIFY*command-object
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ImperativeWithLocation
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   ImperativeWithLocation self.salient.reference <--> command.object.m constraint
sp {comprehend-word*ImperativeWithLocation-constraint*self-salient-reference*UNIFY*command-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ImperativeWithLocation
          ^salient <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^reference { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^reference <target> -
              ^reference <value>)
}

#   Imperative construction
sp {comprehend-word*generalize-cxn*Imperative*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of Imperative
          ^is <a>)
   (<a> -^a Imperative)
-->
   (<a> ^a Imperative)
   (<cxn> ^subcase-of Imperative -
          ^subcase-of VerbWithArguments)
}

#   Propose an operator for the TransitiveCommandParticle construction
sp {comprehend-word*propose*match-construction*TransitiveCommandParticle
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <part>)
   (<part> ^is.a Particle
           ^previous <command>)
   (<command> ^is.a TransitiveCommand
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TransitiveCommandParticle
        ^span 2
        ^lexicals 0
        ^part <part>
        ^command <command>
        ^previous <previous>
        ^debug-info (concat |Match a TransitiveCommandParticle construction, combination 0.|))
}

#   Apply the operator for the TransitiveCommandParticle construction
sp {comprehend-word*apply*match-construction*TransitiveCommandParticle
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TransitiveCommandParticle
        ^command <command>
        ^part <part>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TransitiveCommandParticle
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^command <command>
              ^part <part>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TransitiveCommandParticle)
   (<constituents> ^command <command>
                   ^part <part>)
   (<e-meaning> ^schema ActOnIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TransitiveCommandParticle construction.|))
}

#   TransitiveCommandParticle self.m <--> command.m constraint
sp {comprehend-word*TransitiveCommandParticle-constraint*self-m*UNIFY*command-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveCommandParticle
          ^m { <target> <> <value> }
          ^command <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   Propose an operator for the TransitiveCommand construction
sp {comprehend-word*propose*match-construction*TransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TransitiveCommand
        ^span 2
        ^lexicals 0
        ^object <object>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a TransitiveCommand construction, combination 0.|))
}

#   Apply the operator for the TransitiveCommand construction
sp {comprehend-word*apply*match-construction*TransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TransitiveCommand
        ^verb <verb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TransitiveCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TransitiveCommand)
   (<constituents> ^verb <verb>
                   ^object <object>)
   (<e-meaning> ^schema ActOnIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TransitiveCommand construction.|))
}

#   TransitiveCommand self.m.action <--> verb.m constraint
sp {comprehend-word*TransitiveCommand-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveCommand
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   TransitiveCommand self.m.object <--> object.m constraint
sp {comprehend-word*TransitiveCommand-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveCommand
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the DoUntil construction
sp {comprehend-word*propose*match-construction*DoUntil
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <until>)
   (<until> ^is.a UntilClause
            ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DoUntil
        ^span 2
        ^lexicals 0
        ^until <until>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a DoUntil construction, combination 0.|))
}

#   Apply the operator for the DoUntil construction
sp {comprehend-word*apply*match-construction*DoUntil
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DoUntil
        ^verb <verb>
        ^until <until>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DoUntil
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^verb <verb>
              ^until <until>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a DoUntil)
   (<constituents> ^verb <verb>
                   ^until <until>)
   (<e-meaning> ^schema TerminatedAction
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DoUntil construction.|))
}

#   DoUntil self.m.action <--> verb.m constraint
sp {comprehend-word*DoUntil-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DoUntil
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   DoUntil self.m.terminator <--> until.m constraint
sp {comprehend-word*DoUntil-constraint*self-m-terminator*UNIFY*until-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DoUntil
          ^m <l-slot1>
          ^until <r-slot1>)
   (<l-slot1> ^terminator { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^terminator <target> -
              ^terminator <value>)
}

#   Propose an operator for the MoveOnObjectUntil construction
sp {comprehend-word*propose*match-construction*MoveOnObjectUntil
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <until>)
   (<until> ^is.a UntilClause
            ^previous <command>)
   (<command> ^is.a MotionOnObject
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name MoveOnObjectUntil
        ^span 2
        ^lexicals 0
        ^until <until>
        ^command <command>
        ^previous <previous>
        ^debug-info (concat |Match a MoveOnObjectUntil construction, combination 0.|))
}

#   Apply the operator for the MoveOnObjectUntil construction
sp {comprehend-word*apply*match-construction*MoveOnObjectUntil
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name MoveOnObjectUntil
        ^command <command>
        ^until <until>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name MoveOnObjectUntil
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^command <command>
              ^until <until>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a MoveOnObjectUntil)
   (<constituents> ^command <command>
                   ^until <until>)
   (<e-meaning> ^schema TerminatedActionOnObject
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a MoveOnObjectUntil construction.|))
}

#   MoveOnObjectUntil self.m.action <--> command.verb.m constraint
sp {comprehend-word*MoveOnObjectUntil-constraint*self-m-action*UNIFY*command-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MoveOnObjectUntil
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   MoveOnObjectUntil self.m.object <--> command.object.m constraint
sp {comprehend-word*MoveOnObjectUntil-constraint*self-m-object*UNIFY*command-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MoveOnObjectUntil
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   MoveOnObjectUntil self.m.terminator <--> until.m constraint
sp {comprehend-word*MoveOnObjectUntil-constraint*self-m-terminator*UNIFY*until-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MoveOnObjectUntil
          ^m <l-slot1>
          ^until <r-slot1>)
   (<l-slot1> ^terminator { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^terminator <target> -
              ^terminator <value>)
}

#   UntilClause construction
sp {comprehend-word*generalize-cxn*UntilClause*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of UntilClause
          ^is <a>)
   (<a> -^a UntilClause)
-->
   (<a> ^a UntilClause)
   (<cxn> ^subcase-of UntilClause -)
}

#   Propose an operator for the UntilThereIsClause construction
sp {comprehend-word*propose*match-construction*UntilThereIsClause
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <thereis>)
   (<thereis> ^is.a ThereAre
              ^previous <until>)
   (<until> ^is.a UNTIL
            ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name UntilThereIsClause
        ^span 3
        ^lexicals 1
        ^object <object>
        ^thereis <thereis>
        ^until <until>
        ^previous <previous>
        ^debug-info (concat |Match a UntilThereIsClause construction, combination 0.|))
}

#   Apply the operator for the UntilThereIsClause construction
sp {comprehend-word*apply*match-construction*UntilThereIsClause
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name UntilThereIsClause
        ^until <until>
        ^thereis <thereis>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name UntilThereIsClause
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of UntilClause
              ^constituents <constituents>
              ^until <until>
              ^thereis <thereis>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a UntilThereIsClause)
   (<constituents> ^until <until>
                   ^thereis <thereis>
                   ^object <object>)
   (<e-meaning> ^schema UntilThereIs
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a UntilThereIsClause construction.|))
}

#   UntilThereIsClause self.m.object <--> object.m constraint
sp {comprehend-word*UntilThereIsClause-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a UntilThereIsClause
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   ActionVerb construction
sp {comprehend-word*generalize-cxn*ActionVerb*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of ActionVerb
          ^is <a>)
   (<a> -^a ActionVerb)
-->
   (<a> ^a ActionVerb)
   (<cxn> ^subcase-of ActionVerb -)
}

#   ActionVerbNeedsTarget construction
sp {comprehend-word*generalize-cxn*ActionVerbNeedsTarget*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of ActionVerbNeedsTarget
          ^is <a>)
   (<a> -^a ActionVerbNeedsTarget)
-->
   (<a> ^a ActionVerbNeedsTarget)
   (<cxn> ^subcase-of ActionVerbNeedsTarget -
          ^subcase-of ActionVerb)
}

#   Question construction
sp {comprehend-word*generalize-cxn*Question*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of Question
          ^is <a>)
   (<a> -^a Question)
-->
   (<a> ^a Question)
   (<cxn> ^subcase-of Question -)
}

#   WhQuestion construction
sp {comprehend-word*generalize-cxn*WhQuestion*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of WhQuestion
          ^is <a>)
   (<a> -^a WhQuestion)
-->
   (<a> ^a WhQuestion)
   (<cxn> ^subcase-of WhQuestion -
          ^subcase-of Question)
}

#   YesNoQuestion construction
sp {comprehend-word*generalize-cxn*YesNoQuestion*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of YesNoQuestion
          ^is <a>)
   (<a> -^a YesNoQuestion)
-->
   (<a> ^a YesNoQuestion)
   (<cxn> ^subcase-of YesNoQuestion -
          ^subcase-of Question)
}

#   Propose an operator for the WhatIsObject construction
sp {comprehend-word*propose*match-construction*WhatIsObject
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <what>)
   (<what> ^is.a WHAT
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name WhatIsObject
        ^span 3
        ^lexicals 1
        ^object <object>
        ^tobe <tobe>
        ^what <what>
        ^previous <previous>
        ^debug-info (concat |Match a WhatIsObject construction, combination 0.|))
}

#   Apply the operator for the WhatIsObject construction
sp {comprehend-word*apply*match-construction*WhatIsObject
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name WhatIsObject
        ^what <what>
        ^tobe <tobe>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name WhatIsObject
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of WhQuestion
              ^constituents <constituents>
              ^what <what>
              ^tobe <tobe>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a WhatIsObject)
   (<constituents> ^what <what>
                   ^tobe <tobe>
                   ^object <object>)
   (<e-meaning> ^schema WhatIsObjectQuestion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a WhatIsObject construction.|))
}

#   WhatIsObject self.m.object <--> object.m constraint
sp {comprehend-word*WhatIsObject-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WhatIsObject
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the WhatIsPrepPhrase construction
sp {comprehend-word*propose*match-construction*WhatIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <what>)
   (<what> ^is.a WHAT
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name WhatIsPrepPhrase
        ^span 3
        ^lexicals 1
        ^phrase <phrase>
        ^tobe <tobe>
        ^what <what>
        ^previous <previous>
        ^debug-info (concat |Match a WhatIsPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the WhatIsPrepPhrase construction
sp {comprehend-word*apply*match-construction*WhatIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name WhatIsPrepPhrase
        ^what <what>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name WhatIsPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of WhQuestion
              ^constituents <constituents>
              ^what <what>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a WhatIsPrepPhrase)
   (<constituents> ^what <what>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e-meaning> ^schema WhatIsRelation
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a WhatIsPrepPhrase construction.|))
}

#   WhatIsPrepPhrase self.m.predicate <--> phrase.m constraint
sp {comprehend-word*WhatIsPrepPhrase-constraint*self-m-predicate*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WhatIsPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^predicate { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^predicate <target> -
              ^predicate <value>)
}

#   Propose an operator for the WheresWaldo construction
sp {comprehend-word*propose*match-construction*WheresWaldo
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <where>)
   (<where> ^is.a WHERE
            ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name WheresWaldo
        ^span 3
        ^lexicals 1
        ^object <object>
        ^tobe <tobe>
        ^where <where>
        ^previous <previous>
        ^debug-info (concat |Match a WheresWaldo construction, combination 0.|))
}

#   Apply the operator for the WheresWaldo construction
sp {comprehend-word*apply*match-construction*WheresWaldo
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name WheresWaldo
        ^where <where>
        ^tobe <tobe>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name WheresWaldo
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of WhQuestion
              ^constituents <constituents>
              ^where <where>
              ^tobe <tobe>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a WheresWaldo)
   (<constituents> ^where <where>
                   ^tobe <tobe>
                   ^object <object>)
   (<e-meaning> ^schema WhereIsObject
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a WheresWaldo construction.|))
}

#   WheresWaldo self.m.object <--> object.m constraint
sp {comprehend-word*WheresWaldo-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WheresWaldo
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the WhatClassIsObjectQ construction
sp {comprehend-word*propose*match-construction*WhatClassIsObjectQ
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <class>)
   (<class> ^is.a PropertySet
            ^previous <what>)
   (<what> ^is.a WHAT
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name WhatClassIsObjectQ
        ^span 4
        ^lexicals 1
        ^object <object>
        ^tobe <tobe>
        ^class <class>
        ^what <what>
        ^previous <previous>
        ^debug-info (concat |Match a WhatClassIsObjectQ construction, combination 0.|))
}

#   Apply the operator for the WhatClassIsObjectQ construction
sp {comprehend-word*apply*match-construction*WhatClassIsObjectQ
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name WhatClassIsObjectQ
        ^what <what>
        ^class <class>
        ^tobe <tobe>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name WhatClassIsObjectQ
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of WhQuestion
              ^constituents <constituents>
              ^what <what>
              ^class <class>
              ^tobe <tobe>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a WhatClassIsObjectQ)
   (<constituents> ^what <what>
                   ^class <class>
                   ^tobe <tobe>
                   ^object <object>)
   (<e-meaning> ^schema WhatClassIsObjectQuestion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a WhatClassIsObjectQ construction.|))
}

#   WhatClassIsObjectQ self.m.class <--> class.m constraint
sp {comprehend-word*WhatClassIsObjectQ-constraint*self-m-class*UNIFY*class-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WhatClassIsObjectQ
          ^m <l-slot1>
          ^class <r-slot1>)
   (<l-slot1> ^class { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^class <target> -
              ^class <value>)
}

#   WhatClassIsObjectQ self.m.object <--> object.m constraint
sp {comprehend-word*WhatClassIsObjectQ-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a WhatClassIsObjectQ
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the IsObjectClassQ construction
sp {comprehend-word*propose*match-construction*IsObjectClassQ
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a Property
            ^previous <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IsObjectClassQ
        ^span 3
        ^lexicals 0
        ^class <class>
        ^object <object>
        ^tobe <tobe>
        ^previous <previous>
        ^debug-info (concat |Match a IsObjectClassQ construction, combination 0.|))
}

#   Apply the operator for the IsObjectClassQ construction
sp {comprehend-word*apply*match-construction*IsObjectClassQ
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IsObjectClassQ
        ^tobe <tobe>
        ^object <object>
        ^class <class>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IsObjectClassQ
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of YesNoQuestion
              ^constituents <constituents>
              ^tobe <tobe>
              ^object <object>
              ^class <class>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a IsObjectClassQ)
   (<constituents> ^tobe <tobe>
                   ^object <object>
                   ^class <class>)
   (<e-meaning> ^schema ObjectIsClassQuestion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IsObjectClassQ construction.|))
}

#   IsObjectClassQ self.m.object <--> object.m constraint
sp {comprehend-word*IsObjectClassQ-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectClassQ
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   IsObjectClassQ self.m.class <--> class.m constraint
sp {comprehend-word*IsObjectClassQ-constraint*self-m-class*UNIFY*class-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectClassQ
          ^m <l-slot1>
          ^class <r-slot1>)
   (<l-slot1> ^class { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^class <target> -
              ^class <value>)
}

#   Propose an operator for the IsObjectPropSetQ construction
sp {comprehend-word*propose*match-construction*IsObjectPropSetQ
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <class>)
   (<class> ^is.a PropertySet
            ^previous <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IsObjectPropSetQ
        ^span 3
        ^lexicals 0
        ^class <class>
        ^object <object>
        ^tobe <tobe>
        ^previous <previous>
        ^debug-info (concat |Match a IsObjectPropSetQ construction, combination 0.|))
}

#   Apply the operator for the IsObjectPropSetQ construction
sp {comprehend-word*apply*match-construction*IsObjectPropSetQ
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IsObjectPropSetQ
        ^tobe <tobe>
        ^object <object>
        ^class <class>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IsObjectPropSetQ
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of YesNoQuestion
              ^constituents <constituents>
              ^tobe <tobe>
              ^object <object>
              ^class <class>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a IsObjectPropSetQ)
   (<constituents> ^tobe <tobe>
                   ^object <object>
                   ^class <class>)
   (<e-meaning> ^schema ObjectIsClassQuestion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IsObjectPropSetQ construction.|))
}

#   IsObjectPropSetQ self.m.object <--> object.m constraint
sp {comprehend-word*IsObjectPropSetQ-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectPropSetQ
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   IsObjectPropSetQ self.m.class <--> class.m constraint
sp {comprehend-word*IsObjectPropSetQ-constraint*self-m-class*UNIFY*class-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectPropSetQ
          ^m <l-slot1>
          ^class <r-slot1>)
   (<l-slot1> ^class { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^class <target> -
              ^class <value>)
}

#   Propose an operator for the IsObjectRelation construction
sp {comprehend-word*propose*match-construction*IsObjectRelation
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <relation>)
   (<relation> ^is.a PrepPhrase
               ^previous <object>)
   (<object> ^is.a RefExpr
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IsObjectRelation
        ^span 3
        ^lexicals 0
        ^relation <relation>
        ^object <object>
        ^tobe <tobe>
        ^previous <previous>
        ^debug-info (concat |Match a IsObjectRelation construction, combination 0.|))
}

#   Apply the operator for the IsObjectRelation construction
sp {comprehend-word*apply*match-construction*IsObjectRelation
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IsObjectRelation
        ^tobe <tobe>
        ^object <object>
        ^relation <relation>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IsObjectRelation
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of YesNoQuestion
              ^constituents <constituents>
              ^tobe <tobe>
              ^object <object>
              ^relation <relation>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a IsObjectRelation)
   (<constituents> ^tobe <tobe>
                   ^object <object>
                   ^relation <relation>)
   (<e-meaning> ^schema ObjectIsRelationQuestion
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IsObjectRelation construction.|))
}

#   IsObjectRelation self.m.object <--> object.m constraint
sp {comprehend-word*IsObjectRelation-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectRelation
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   IsObjectRelation self.m.relation <--> relation.m constraint
sp {comprehend-word*IsObjectRelation-constraint*self-m-relation*UNIFY*relation-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IsObjectRelation
          ^m <l-slot1>
          ^relation <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   Propose an operator for the DriveVerbToTarget construction
sp {comprehend-word*propose*match-construction*DriveVerbToTarget
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <target>)
   (<target> ^is.a PrepPhrase
             ^previous <verb>)
   (<verb> ^is.a DriveVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DriveVerbToTarget
        ^span 2
        ^lexicals 0
        ^target <target>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a DriveVerbToTarget construction, combination 0.|))
}

#   Apply the operator for the DriveVerbToTarget construction
sp {comprehend-word*apply*match-construction*DriveVerbToTarget
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DriveVerbToTarget
        ^verb <verb>
        ^target <target>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DriveVerbToTarget
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^target <target>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a DriveVerbToTarget)
   (<constituents> ^verb <verb>
                   ^target <target>)
   (<e-meaning> ^schema MoveToIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DriveVerbToTarget construction.|))
}

#   DriveVerbToTarget self.m.action <--> verb.m constraint
sp {comprehend-word*DriveVerbToTarget-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DriveVerbToTarget
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   DriveVerbToTarget self.m.location <--> target.m constraint
sp {comprehend-word*DriveVerbToTarget-constraint*self-m-location*UNIFY*target-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DriveVerbToTarget
          ^m <l-slot1>
          ^target <r-slot1>)
   (<l-slot1> ^location { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^location <target> -
              ^location <value>)
}

#   DriveVerb construction
sp {comprehend-word*generalize-cxn*DriveVerb*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of DriveVerb
          ^is <a>
          ^m <meaning>)
   (<a> -^a DriveVerb)
-->
   (<a> ^a DriveVerb)
   (<cxn> ^subcase-of DriveVerb -
          ^subcase-of SimpleMotionVerb
          ^evokes <e-meaning>)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   DriveVerb self.m.name <-- "go-to-location1" constraint
sp {comprehend-word*DriveVerb-constraint*self-m-name*ASSIGN*go-to-location1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DriveVerb
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |go-to-location1| })
-->
   (<l-slot1> ^name <target> -
              ^name |go-to-location1|)
}

#   Propose an operator for the DriveInDirection construction
sp {comprehend-word*propose*match-construction*DriveInDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a Direction
                ^previous <verb>)
   (<verb> ^is.a DriveVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DriveInDirection
        ^span 2
        ^lexicals 0
        ^direction <direction>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a DriveInDirection construction, combination 0.|))
}

#   Apply the operator for the DriveInDirection construction
sp {comprehend-word*apply*match-construction*DriveInDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DriveInDirection
        ^verb <verb>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DriveInDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a DriveInDirection)
   (<constituents> ^verb <verb>
                   ^direction <direction>)
   (<e-meaning> ^schema Action
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DriveInDirection construction.|))
}

#   DriveInDirection self.m.action <--> verb.m constraint
sp {comprehend-word*DriveInDirection-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DriveInDirection
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   DriveInDirection self.m.direction <--> direction.m constraint
sp {comprehend-word*DriveInDirection-constraint*self-m-direction*UNIFY*direction-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DriveInDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   Propose an operator for the ActInDirection construction
sp {comprehend-word*propose*match-construction*ActInDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a Direction
                ^previous <action>)
   (<action> ^is.a SimpleAction
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ActInDirection
        ^span 2
        ^lexicals 0
        ^direction <direction>
        ^action <action>
        ^previous <previous>
        ^debug-info (concat |Match a ActInDirection construction, combination 0.|))
}

#   Apply the operator for the ActInDirection construction
sp {comprehend-word*apply*match-construction*ActInDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ActInDirection
        ^action <action>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ActInDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^action <action>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ActInDirection)
   (<constituents> ^action <action>
                   ^direction <direction>)
   (<e-meaning> ^schema DoItInDirection
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ActInDirection construction.|))
}

#   ActInDirection self.m.action <--> action.verb.m constraint
sp {comprehend-word*ActInDirection-constraint*self-m-action*UNIFY*action-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActInDirection
          ^m <l-slot1>
          ^action <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   ActInDirection self.m.direction <--> direction.m constraint
sp {comprehend-word*ActInDirection-constraint*self-m-direction*UNIFY*direction-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActInDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   Propose an operator for the ActAlongDirection construction
sp {comprehend-word*propose*match-construction*ActAlongDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a DirectionalPrepPhrase
                ^previous <action>)
   (<action> ^is.a SimpleAction
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ActAlongDirection
        ^span 2
        ^lexicals 0
        ^direction <direction>
        ^action <action>
        ^previous <previous>
        ^debug-info (concat |Match a ActAlongDirection construction, combination 0.|))
}

#   Apply the operator for the ActAlongDirection construction
sp {comprehend-word*apply*match-construction*ActAlongDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ActAlongDirection
        ^action <action>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ActAlongDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^action <action>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a ActAlongDirection)
   (<constituents> ^action <action>
                   ^direction <direction>)
   (<e-meaning> ^schema DoItInDirection
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ActAlongDirection construction.|))
}

#   ActAlongDirection self.m.action <--> action.verb.m constraint
sp {comprehend-word*ActAlongDirection-constraint*self-m-action*UNIFY*action-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActAlongDirection
          ^m <l-slot1>
          ^action <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   ActAlongDirection self.m.direction <--> direction.m.prep constraint
sp {comprehend-word*ActAlongDirection-constraint*self-m-direction*UNIFY*direction-m-prep
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActAlongDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^prep <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   ActAlongDirection self.m.object <--> direction.m.object constraint
sp {comprehend-word*ActAlongDirection-constraint*self-m-object*UNIFY*direction-m-object
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActAlongDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <r-slot2>)
   (<r-slot2> ^object <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the SimpleAction construction
sp {comprehend-word*propose*match-construction*SimpleAction
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <verb>)
   (<verb> ^is.a SimpleMotionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SimpleAction
        ^span 1
        ^lexicals 0
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a SimpleAction construction, combination 0.|))
}

#   Apply the operator for the SimpleAction construction
sp {comprehend-word*apply*match-construction*SimpleAction
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SimpleAction
        ^verb <verb>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SimpleAction
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a SimpleAction)
   (<constituents> ^verb <verb>)
   (<e-meaning> ^schema Action
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SimpleAction construction.|))
}

#   SimpleAction self.m.action <--> verb.m constraint
sp {comprehend-word*SimpleAction-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SimpleAction
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   SimpleMotionVerb construction
sp {comprehend-word*generalize-cxn*SimpleMotionVerb*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of SimpleMotionVerb
          ^is <a>
          ^m <meaning>)
   (<a> -^a SimpleMotionVerb)
-->
   (<a> ^a SimpleMotionVerb)
   (<cxn> ^subcase-of SimpleMotionVerb -
          ^subcase-of ActionVerb
          ^evokes <e-meaning>)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   SimpleMotionVerb self.m.class <-- @action constraint
sp {comprehend-word*SimpleMotionVerb-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SimpleMotionVerb
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   Propose an operator for the TurnDirection construction
sp {comprehend-word*propose*match-construction*TurnDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a Direction
                ^previous <verb>)
   (<verb> ^is.a TurnVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TurnDirection
        ^span 2
        ^lexicals 0
        ^direction <direction>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a TurnDirection construction, combination 0.|))
}

#   Apply the operator for the TurnDirection construction
sp {comprehend-word*apply*match-construction*TurnDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TurnDirection
        ^verb <verb>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TurnDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TurnDirection)
   (<constituents> ^verb <verb>
                   ^direction <direction>)
   (<e-meaning> ^schema TurnToIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TurnDirection construction.|))
}

#   TurnDirection self.m.action <--> verb.m constraint
sp {comprehend-word*TurnDirection-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnDirection
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   TurnDirection self.m.direction <--> direction.m constraint
sp {comprehend-word*TurnDirection-constraint*self-m-direction*UNIFY*direction-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   Propose an operator for the TurnToDirection construction
sp {comprehend-word*propose*match-construction*TurnToDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a Direction
                ^previous <to>)
   (<to> ^is.a TO
         ^previous <verb>)
   (<verb> ^is.a TurnVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TurnToDirection
        ^span 3
        ^lexicals 1
        ^direction <direction>
        ^to <to>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a TurnToDirection construction, combination 0.|))
}

#   Apply the operator for the TurnToDirection construction
sp {comprehend-word*apply*match-construction*TurnToDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TurnToDirection
        ^verb <verb>
        ^to <to>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TurnToDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^to <to>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TurnToDirection)
   (<constituents> ^verb <verb>
                   ^to <to>
                   ^direction <direction>)
   (<e-meaning> ^schema TurnToIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TurnToDirection construction.|))
}

#   TurnToDirection self.m.action <--> verb.m constraint
sp {comprehend-word*TurnToDirection-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnToDirection
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   TurnToDirection self.m.direction <--> direction.m constraint
sp {comprehend-word*TurnToDirection-constraint*self-m-direction*UNIFY*direction-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnToDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   Propose an operator for the TurnToTheDirection construction
sp {comprehend-word*propose*match-construction*TurnToTheDirection
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <direction>)
   (<direction> ^is.a Direction
                ^previous <the>)
   (<the> ^is.a THE
          ^previous <to>)
   (<to> ^is.a TO
         ^previous <verb>)
   (<verb> ^is.a TurnVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TurnToTheDirection
        ^span 4
        ^lexicals 2
        ^direction <direction>
        ^the <the>
        ^to <to>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a TurnToTheDirection construction, combination 0.|))
}

#   Apply the operator for the TurnToTheDirection construction
sp {comprehend-word*apply*match-construction*TurnToTheDirection
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TurnToTheDirection
        ^verb <verb>
        ^to <to>
        ^the <the>
        ^direction <direction>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TurnToTheDirection
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^to <to>
              ^the <the>
              ^direction <direction>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a TurnToTheDirection)
   (<constituents> ^verb <verb>
                   ^to <to>
                   ^the <the>
                   ^direction <direction>)
   (<e-meaning> ^schema TurnToIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TurnToTheDirection construction.|))
}

#   TurnToTheDirection self.m.action <--> verb.m constraint
sp {comprehend-word*TurnToTheDirection-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnToTheDirection
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   TurnToTheDirection self.m.direction <--> direction.m constraint
sp {comprehend-word*TurnToTheDirection-constraint*self-m-direction*UNIFY*direction-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TurnToTheDirection
          ^m <l-slot1>
          ^direction <r-slot1>)
   (<l-slot1> ^direction { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^direction <target> -
              ^direction <value>)
}

#   MotionVerb construction
sp {comprehend-word*generalize-cxn*MotionVerb*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of MotionVerb
          ^is <a>
          ^m <meaning>)
   (<a> -^a MotionVerb)
-->
   (<a> ^a MotionVerb)
   (<cxn> ^subcase-of MotionVerb -
          ^evokes <e-meaning>)
   (<e-meaning> ^schema ActionDescriptor
                ^target <meaning>)
}

#   MotionVerb self.m.class <-- @action constraint
sp {comprehend-word*MotionVerb-constraint*self-m-class*ASSIGN*AT-action
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MotionVerb
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |action| })
-->
   (<l-slot1> ^class <target> -
              ^class |action|)
}

#   TurnVerb construction
sp {comprehend-word*generalize-cxn*TurnVerb*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of TurnVerb
          ^is <a>)
   (<a> -^a TurnVerb)
-->
   (<a> ^a TurnVerb)
   (<cxn> ^subcase-of TurnVerb -
          ^subcase-of MotionVerb)
}

#   Propose an operator for the MotionOnObject construction
sp {comprehend-word*propose*match-construction*MotionOnObject
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a MotionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name MotionOnObject
        ^span 2
        ^lexicals 0
        ^object <object>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a MotionOnObject construction, combination 0.|))
}

#   Apply the operator for the MotionOnObject construction
sp {comprehend-word*apply*match-construction*MotionOnObject
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name MotionOnObject
        ^verb <verb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name MotionOnObject
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^object <object>
              ^evokes <e-meaning>
              ^previous <previous>)
   (<a> ^a MotionOnObject)
   (<constituents> ^verb <verb>
                   ^object <object>)
   (<e-meaning> ^schema ActOnIt
                ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a MotionOnObject construction.|))
}

#   MotionOnObject self.m.action <--> verb.m constraint
sp {comprehend-word*MotionOnObject-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MotionOnObject
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   MotionOnObject self.m.object <--> object.m constraint
sp {comprehend-word*MotionOnObject-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MotionOnObject
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

