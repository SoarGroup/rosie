#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\lingschemas.ecg'.

#   WordForm schema
sp {comprehend-word*evoked-schema*WordForm*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema WordForm
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name WordForm
               ^is <a>
               ^orth nil)
   (<a> ^a WordForm)
}

#   WordForm schema
sp {comprehend-word*evoked-schema*WordForm*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema WordForm
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^orth nil)
   (<a> ^a WordForm)
}

#   EventDescriptor schema
sp {comprehend-word*evoked-schema*EventDescriptor*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema EventDescriptor
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name EventDescriptor
               ^is <a>
               ^eventType <r1>
               ^profiledProcess <r2>
               ^profiledParticipant nil
               ^profiledState nil
               ^spatialSetting nil
               ^temporalSetting nil
               ^speechAct nil)
   (<a> ^a EventDescriptor)
   (<e1> ^schema Process
         ^target <r1>)
   (<e2> ^schema Process
         ^target <r2>)
}

#   EventDescriptor schema
sp {comprehend-word*evoked-schema*EventDescriptor*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema EventDescriptor
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^eventType <r1>
               ^profiledProcess <r2>
               ^profiledParticipant nil
               ^profiledState nil
               ^spatialSetting nil
               ^temporalSetting nil
               ^speechAct nil)
   (<a> ^a EventDescriptor)
   (<e1> ^schema Process
         ^target <r1>)
   (<e2> ^schema Process
         ^target <r2>)
}

#   RefDesc schema
sp {comprehend-word*evoked-schema*RefDesc*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema RefDesc
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name RefDesc
               ^is <a>
               ^name nil
               ^category nil
               ^givenness nil
               ^modifiers nil
               ^referent nil
               ^relation nil
               ^quantified nil)
   (<a> ^a RefDesc)
}

#   RefDesc schema
sp {comprehend-word*evoked-schema*RefDesc*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema RefDesc
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^name nil
               ^category nil
               ^givenness nil
               ^modifiers nil
               ^referent nil
               ^relation nil
               ^quantified nil)
   (<a> ^a RefDesc)
}

#   Quantification schema
sp {comprehend-word*evoked-schema*Quantification*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Quantification
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name Quantification
               ^is <a>
               ^type nil)
   (<a> ^a Quantification)
}

#   Quantification schema
sp {comprehend-word*evoked-schema*Quantification*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Quantification
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^type nil)
   (<a> ^a Quantification)
}

#   PropertyDefinition schema
sp {comprehend-word*evoked-schema*PropertyDefinition*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyDefinition
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PropertyDefinition
               ^is <a>
               ^word nil
               ^class nil)
   (<a> ^a PropertyDefinition)
}

#   PropertyDefinition schema
sp {comprehend-word*evoked-schema*PropertyDefinition*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyDefinition
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^word nil
               ^class nil)
   (<a> ^a PropertyDefinition)
}

#   PropertyRedefinition schema
sp {comprehend-word*evoked-schema*PropertyRedefinition*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyRedefinition
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PropertyRedefinition
               ^is <a>
               ^word nil
               ^old nil
               ^class nil)
   (<a> ^a PropertyRedefinition)
}

#   PropertyRedefinition schema
sp {comprehend-word*evoked-schema*PropertyRedefinition*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyRedefinition
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^word nil
               ^old nil
               ^class nil)
   (<a> ^a PropertyRedefinition)
}

#   PropertySetDescriptor schema
sp {comprehend-word*evoked-schema*PropertySetDescriptor*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertySetDescriptor
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PropertySetDescriptor
               ^is <a>
               ^predicate nil
               ^givenness nil
               ^property nil
               ^property2 nil)
   (<a> ^a PropertySetDescriptor)
}

#   PropertySetDescriptor schema
sp {comprehend-word*evoked-schema*PropertySetDescriptor*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertySetDescriptor
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^predicate nil
               ^givenness nil
               ^property nil
               ^property2 nil)
   (<a> ^a PropertySetDescriptor)
}

#   PropertyClassDescriptor schema
sp {comprehend-word*evoked-schema*PropertyClassDescriptor*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyClassDescriptor
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PropertyClassDescriptor
               ^is <a>
               ^name nil)
   (<a> ^a PropertyClassDescriptor)
}

#   PropertyClassDescriptor schema
sp {comprehend-word*evoked-schema*PropertyClassDescriptor*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyClassDescriptor
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^name nil)
   (<a> ^a PropertyClassDescriptor)
}

#   PropertyDescriptor schema
sp {comprehend-word*evoked-schema*PropertyDescriptor*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyDescriptor
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PropertyDescriptor
               ^is <a>
               ^class nil
               ^name nil
               ^next nil)
   (<a> ^a PropertyDescriptor)
}

#   PropertyDescriptor schema
sp {comprehend-word*evoked-schema*PropertyDescriptor*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyDescriptor
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^class nil
               ^name nil
               ^next nil)
   (<a> ^a PropertyDescriptor)
}

#   ActionDescriptor schema
sp {comprehend-word*evoked-schema*ActionDescriptor*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ActionDescriptor
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name ActionDescriptor
               ^is <a>
               ^class nil
               ^name nil
               ^modifier nil)
   (<a> ^a ActionDescriptor)
}

#   ActionDescriptor schema
sp {comprehend-word*evoked-schema*ActionDescriptor*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ActionDescriptor
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^class nil
               ^name nil
               ^modifier nil)
   (<a> ^a ActionDescriptor)
}

#   Assertion schema
sp {comprehend-word*evoked-schema*Assertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Assertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name Assertion
               ^is <a>)
   (<a> ^a Assertion)
}

#   Assertion schema
sp {comprehend-word*evoked-schema*Assertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Assertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<a> ^a Assertion)
}

#   PropertyApplication schema
sp {comprehend-word*evoked-schema*PropertyApplication*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyApplication
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^schema-name PropertyApplication
               ^is <a>
               ^property <r1>
               ^target <r2>)
   (<a> ^a PropertyApplication)
   (<e1> ^schema PropertyDescriptor
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   PropertyApplication schema
sp {comprehend-word*evoked-schema*PropertyApplication*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PropertyApplication
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^property <r1>
               ^target <r2>)
   (<a> ^a PropertyApplication)
   (<e1> ^schema PropertyDescriptor
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   PrepPhraseAssertion schema
sp {comprehend-word*evoked-schema*PrepPhraseAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepPhraseAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^schema-name PrepPhraseAssertion
               ^is <a>
               ^preprel <r1>
               ^target <r2>
               ^modifier nil)
   (<a> ^a PrepPhraseAssertion)
   (<e1> ^schema PrepRelation
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   PrepPhraseAssertion schema
sp {comprehend-word*evoked-schema*PrepPhraseAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepPhraseAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^preprel <r1>
               ^target <r2>
               ^modifier nil)
   (<a> ^a PrepPhraseAssertion)
   (<e1> ^schema PrepRelation
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   ThisIsAThatAssertion schema
sp {comprehend-word*evoked-schema*ThisIsAThatAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ThisIsAThatAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^schema-name ThisIsAThatAssertion
               ^is <a>
               ^this <r1>
               ^that <r2>)
   (<a> ^a ThisIsAThatAssertion)
   (<e1> ^schema RefDesc
         ^target <r1>)
   (<e2> ^schema PropertyClassDescriptor
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   ThisIsAThatAssertion schema
sp {comprehend-word*evoked-schema*ThisIsAThatAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ThisIsAThatAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^this <r1>
               ^that <r2>)
   (<a> ^a ThisIsAThatAssertion)
   (<e1> ^schema RefDesc
         ^target <r1>)
   (<e2> ^schema PropertyClassDescriptor
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   ThisIsTheThatAssertion schema
sp {comprehend-word*evoked-schema*ThisIsTheThatAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ThisIsTheThatAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^schema-name ThisIsTheThatAssertion
               ^is <a>
               ^this <r1>
               ^that <r2>)
   (<a> ^a ThisIsTheThatAssertion)
   (<e1> ^schema RefDesc
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   ThisIsTheThatAssertion schema
sp {comprehend-word*evoked-schema*ThisIsTheThatAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ThisIsTheThatAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>
          ^evokes <e3>)
   (<e-target> ^this <r1>
               ^that <r2>)
   (<a> ^a ThisIsTheThatAssertion)
   (<e1> ^schema RefDesc
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
   (<e3> ^schema Assertion
         ^target <e-target>)
}

#   PrepRelation schema
sp {comprehend-word*evoked-schema*PrepRelation*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepRelation
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name PrepRelation
               ^is <a>
               ^prep <r1>
               ^object <r2>)
   (<a> ^a PrepRelation)
   (<e1> ^schema PrepCore
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
}

#   PrepRelation schema
sp {comprehend-word*evoked-schema*PrepRelation*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepRelation
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^prep <r1>
               ^object <r2>)
   (<a> ^a PrepRelation)
   (<e1> ^schema PrepCore
         ^target <r1>)
   (<e2> ^schema RefDesc
         ^target <r2>)
}

#   PrepCore schema
sp {comprehend-word*evoked-schema*PrepCore*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepCore
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name PrepCore
               ^is <a>
               ^name nil)
   (<a> ^a PrepCore)
}

#   PrepCore schema
sp {comprehend-word*evoked-schema*PrepCore*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PrepCore
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^name nil)
   (<a> ^a PrepCore)
}

#   AgreementFeatures schema
sp {comprehend-word*evoked-schema*AgreementFeatures*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema AgreementFeatures
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name AgreementFeatures
               ^is <a>
               ^number nil
               ^person nil)
   (<a> ^a AgreementFeatures)
}

#   AgreementFeatures schema
sp {comprehend-word*evoked-schema*AgreementFeatures*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema AgreementFeatures
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^number nil
               ^person nil)
   (<a> ^a AgreementFeatures)
}

#   NominalAgreementFeatures schema
sp {comprehend-word*evoked-schema*NominalAgreementFeatures*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NominalAgreementFeatures
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name NominalAgreementFeatures
               ^is <a>
               ^case nil)
   (<a> ^a NominalAgreementFeatures)
   (<e1> ^schema AgreementFeatures
         ^target <e-target>)
}

#   NominalAgreementFeatures schema
sp {comprehend-word*evoked-schema*NominalAgreementFeatures*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NominalAgreementFeatures
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^case nil)
   (<a> ^a NominalAgreementFeatures)
   (<e1> ^schema AgreementFeatures
         ^target <e-target>)
}

#   VerbAgreementFeatures schema
sp {comprehend-word*evoked-schema*VerbAgreementFeatures*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbAgreementFeatures
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name VerbAgreementFeatures
               ^is <a>
               ^verbform nil)
   (<a> ^a VerbAgreementFeatures)
   (<e1> ^schema AgreementFeatures
         ^target <e-target>)
}

#   VerbAgreementFeatures schema
sp {comprehend-word*evoked-schema*VerbAgreementFeatures*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbAgreementFeatures
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^verbform nil)
   (<a> ^a VerbAgreementFeatures)
   (<e1> ^schema AgreementFeatures
         ^target <e-target>)
}

#   NominalFeatures schema
sp {comprehend-word*evoked-schema*NominalFeatures*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NominalFeatures
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name NominalFeatures
               ^is <a>
               ^features <r1>)
   (<a> ^a NominalFeatures)
   (<e1> ^schema NominalAgreementFeatures
         ^target <r1>)
}

#   NominalFeatures schema
sp {comprehend-word*evoked-schema*NominalFeatures*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NominalFeatures
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^features <r1>)
   (<a> ^a NominalFeatures)
   (<e1> ^schema NominalAgreementFeatures
         ^target <r1>)
}

#   VerbFeatures schema
sp {comprehend-word*evoked-schema*VerbFeatures*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbFeatures
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name VerbFeatures
               ^is <a>
               ^features <r1>)
   (<a> ^a VerbFeatures)
   (<e1> ^schema VerbAgreementFeatures
         ^target <r1>)
}

#   VerbFeatures schema
sp {comprehend-word*evoked-schema*VerbFeatures*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbFeatures
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^features <r1>)
   (<a> ^a VerbFeatures)
   (<e1> ^schema VerbAgreementFeatures
         ^target <r1>)
}

#   YesNoAnswer schema
sp {comprehend-word*evoked-schema*YesNoAnswer*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema YesNoAnswer
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name YesNoAnswer
               ^is <a>
               ^answer nil)
   (<a> ^a YesNoAnswer)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   YesNoAnswer schema
sp {comprehend-word*evoked-schema*YesNoAnswer*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema YesNoAnswer
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^answer nil)
   (<a> ^a YesNoAnswer)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   FiniteOrNonFinite schema
sp {comprehend-word*evoked-schema*FiniteOrNonFinite*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema FiniteOrNonFinite
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name FiniteOrNonFinite
               ^is <a>)
   (<a> ^a FiniteOrNonFinite)
}

#   FiniteOrNonFinite schema
sp {comprehend-word*evoked-schema*FiniteOrNonFinite*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema FiniteOrNonFinite
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<a> ^a FiniteOrNonFinite)
}

#   Finite schema
sp {comprehend-word*evoked-schema*Finite*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Finite
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name Finite
               ^is <a>)
   (<a> ^a Finite)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
   (<e2> ^schema FiniteOrGerund
         ^target <e-target>)
}

#   Finite schema
sp {comprehend-word*evoked-schema*Finite*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Finite
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<a> ^a Finite)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
   (<e2> ^schema FiniteOrGerund
         ^target <e-target>)
}

#   NonFinite schema
sp {comprehend-word*evoked-schema*NonFinite*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NonFinite
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name NonFinite
               ^is <a>)
   (<a> ^a NonFinite)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
}

#   NonFinite schema
sp {comprehend-word*evoked-schema*NonFinite*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema NonFinite
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a NonFinite)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
}

#   Infinitive schema
sp {comprehend-word*evoked-schema*Infinitive*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Infinitive
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Infinitive
               ^is <a>)
   (<a> ^a Infinitive)
   (<e1> ^schema NonFinite
         ^target <e-target>)
}

#   Infinitive schema
sp {comprehend-word*evoked-schema*Infinitive*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Infinitive
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Infinitive)
   (<e1> ^schema NonFinite
         ^target <e-target>)
}

#   Gerund schema
sp {comprehend-word*evoked-schema*Gerund*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Gerund
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<e-target> ^schema-name Gerund
               ^is <a>)
   (<a> ^a Gerund)
   (<e1> ^schema NonFinite
         ^target <e-target>)
   (<e2> ^schema FiniteOrGerund
         ^target <e-target>)
}

#   Gerund schema
sp {comprehend-word*evoked-schema*Gerund*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Gerund
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>
          ^evokes <e2>)
   (<a> ^a Gerund)
   (<e1> ^schema NonFinite
         ^target <e-target>)
   (<e2> ^schema FiniteOrGerund
         ^target <e-target>)
}

#   PastParticiple schema
sp {comprehend-word*evoked-schema*PastParticiple*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PastParticiple
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name PastParticiple
               ^is <a>)
   (<a> ^a PastParticiple)
   (<e1> ^schema NonFinite
         ^target <e-target>)
}

#   PastParticiple schema
sp {comprehend-word*evoked-schema*PastParticiple*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema PastParticiple
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a PastParticiple)
   (<e1> ^schema NonFinite
         ^target <e-target>)
}

#   FiniteOrGerund schema
sp {comprehend-word*evoked-schema*FiniteOrGerund*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema FiniteOrGerund
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name FiniteOrGerund
               ^is <a>)
   (<a> ^a FiniteOrGerund)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
}

#   FiniteOrGerund schema
sp {comprehend-word*evoked-schema*FiniteOrGerund*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema FiniteOrGerund
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a FiniteOrGerund)
   (<e1> ^schema FiniteOrNonFinite
         ^target <e-target>)
}

