#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-lingschemas.ecg'.

#   IntransitiveAssertion schema
sp {comprehend-word*evoked-schema*IntransitiveAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema IntransitiveAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name IntransitiveAssertion
               ^is <a>
               ^subject nil
               ^verb nil)
   (<a> ^a IntransitiveAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   IntransitiveAssertion schema
sp {comprehend-word*evoked-schema*IntransitiveAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema IntransitiveAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^subject nil
               ^verb nil)
   (<a> ^a IntransitiveAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   TransitiveAssertion schema
sp {comprehend-word*evoked-schema*TransitiveAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name TransitiveAssertion
               ^is <a>
               ^subject nil
               ^verb nil
               ^object nil)
   (<a> ^a TransitiveAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   TransitiveAssertion schema
sp {comprehend-word*evoked-schema*TransitiveAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^subject nil
               ^verb nil
               ^object nil)
   (<a> ^a TransitiveAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   TransitiveAssertionPrepPhrase schema
sp {comprehend-word*evoked-schema*TransitiveAssertionPrepPhrase*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveAssertionPrepPhrase
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name TransitiveAssertionPrepPhrase
               ^is <a>
               ^subject nil
               ^verb nil
               ^object nil
               ^relation nil)
   (<a> ^a TransitiveAssertionPrepPhrase)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   TransitiveAssertionPrepPhrase schema
sp {comprehend-word*evoked-schema*TransitiveAssertionPrepPhrase*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveAssertionPrepPhrase
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^subject nil
               ^verb nil
               ^object nil
               ^relation nil)
   (<a> ^a TransitiveAssertionPrepPhrase)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   CompoundAssertion schema
sp {comprehend-word*evoked-schema*CompoundAssertion*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema CompoundAssertion
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name CompoundAssertion
               ^is <a>
               ^assertion1 nil
               ^assertion2 nil)
   (<a> ^a CompoundAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   CompoundAssertion schema
sp {comprehend-word*evoked-schema*CompoundAssertion*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema CompoundAssertion
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^assertion1 nil
               ^assertion2 nil)
   (<a> ^a CompoundAssertion)
   (<e1> ^schema Assertion
         ^target <e-target>)
}

#   AskQuestionCommand schema
sp {comprehend-word*evoked-schema*AskQuestionCommand*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema AskQuestionCommand
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name AskQuestionCommand
               ^is <a>)
   (<a> ^a AskQuestionCommand)
   (<e1> ^schema ActOnIt
         ^target <e-target>)
}

#   AskQuestionCommand schema
sp {comprehend-word*evoked-schema*AskQuestionCommand*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema AskQuestionCommand
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a AskQuestionCommand)
   (<e1> ^schema ActOnIt
         ^target <e-target>)
}

#   VerbDefinition schema
sp {comprehend-word*evoked-schema*VerbDefinition*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbDefinition
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name VerbDefinition
               ^is <a>
               ^word nil)
   (<a> ^a VerbDefinition)
}

#   VerbDefinition schema
sp {comprehend-word*evoked-schema*VerbDefinition*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema VerbDefinition
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^word nil)
   (<a> ^a VerbDefinition)
}

#   TransitiveVerbDefinition schema
sp {comprehend-word*evoked-schema*TransitiveVerbDefinition*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveVerbDefinition
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name TransitiveVerbDefinition
               ^is <a>
               ^object nil)
   (<a> ^a TransitiveVerbDefinition)
   (<e1> ^schema VerbDefinition
         ^target <e-target>)
}

#   TransitiveVerbDefinition schema
sp {comprehend-word*evoked-schema*TransitiveVerbDefinition*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema TransitiveVerbDefinition
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^object nil)
   (<a> ^a TransitiveVerbDefinition)
   (<e1> ^schema VerbDefinition
         ^target <e-target>)
}

#   IntransitiveVerbDefinition schema
sp {comprehend-word*evoked-schema*IntransitiveVerbDefinition*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema IntransitiveVerbDefinition
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name IntransitiveVerbDefinition
               ^is <a>
               ^location nil)
   (<a> ^a IntransitiveVerbDefinition)
   (<e1> ^schema VerbDefinition
         ^target <e-target>)
}

#   IntransitiveVerbDefinition schema
sp {comprehend-word*evoked-schema*IntransitiveVerbDefinition*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema IntransitiveVerbDefinition
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^location nil)
   (<a> ^a IntransitiveVerbDefinition)
   (<e1> ^schema VerbDefinition
         ^target <e-target>)
}

#   Salient schema
sp {comprehend-word*evoked-schema*Salient*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Salient
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^schema-name Salient
               ^is <a>
               ^reference nil)
   (<a> ^a Salient)
}

#   Salient schema
sp {comprehend-word*evoked-schema*Salient*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Salient
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -)
   (<e-target> ^reference nil)
   (<a> ^a Salient)
}

