#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\x-properties.ecg'.

#   North construction
sp {comprehend-word*generalize-cxn*North*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of North
          ^is <a>
          ^m <meaning>)
   (<a> -^a North)
-->
   (<a> ^a North)
   (<cxn> ^subcase-of North -
          ^subcase-of Direction
          ^evokes <e-meaning>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   North self.m.class <-- @cardinal-direction1 constraint
sp {comprehend-word*North-constraint*self-m-class*ASSIGN*AT-cardinal-direction1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a North
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |cardinal-direction1| })
-->
   (<l-slot1> ^class <target> -
              ^class |cardinal-direction1|)
}

#   North self.m.name <-- "north1" constraint
sp {comprehend-word*North-constraint*self-m-name*ASSIGN*north1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a North
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |north1| })
-->
   (<l-slot1> ^name <target> -
              ^name |north1|)
}

#   NORTH construction
sp {comprehend-word*apply*lexical-access*NORTH-north
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |north|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name NORTH
          ^is <a>
          ^orth |north|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of North
          ^first-lex nil)
   (<a> ^a NORTH)
}

#   N construction
sp {comprehend-word*apply*lexical-access*N-n
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |n|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name N
          ^is <a>
          ^orth |n|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of North
          ^first-lex nil)
   (<a> ^a N)
}

#   South construction
sp {comprehend-word*generalize-cxn*South*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of South
          ^is <a>
          ^m <meaning>)
   (<a> -^a South)
-->
   (<a> ^a South)
   (<cxn> ^subcase-of South -
          ^subcase-of Direction
          ^evokes <e-meaning>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   South self.m.class <-- @cardinal-direction1 constraint
sp {comprehend-word*South-constraint*self-m-class*ASSIGN*AT-cardinal-direction1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a South
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |cardinal-direction1| })
-->
   (<l-slot1> ^class <target> -
              ^class |cardinal-direction1|)
}

#   South self.m.name <-- "south1" constraint
sp {comprehend-word*South-constraint*self-m-name*ASSIGN*south1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a South
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |south1| })
-->
   (<l-slot1> ^name <target> -
              ^name |south1|)
}

#   SOUTH construction
sp {comprehend-word*apply*lexical-access*SOUTH-south
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |south|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SOUTH
          ^is <a>
          ^orth |south|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of South
          ^first-lex nil)
   (<a> ^a SOUTH)
}

#   S construction
sp {comprehend-word*apply*lexical-access*S-s
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |s|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name S
          ^is <a>
          ^orth |s|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of South
          ^first-lex nil)
   (<a> ^a S)
}

#   East construction
sp {comprehend-word*generalize-cxn*East*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of East
          ^is <a>
          ^m <meaning>)
   (<a> -^a East)
-->
   (<a> ^a East)
   (<cxn> ^subcase-of East -
          ^subcase-of Direction
          ^evokes <e-meaning>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   East self.m.class <-- @cardinal-direction1 constraint
sp {comprehend-word*East-constraint*self-m-class*ASSIGN*AT-cardinal-direction1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a East
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |cardinal-direction1| })
-->
   (<l-slot1> ^class <target> -
              ^class |cardinal-direction1|)
}

#   East self.m.name <-- "east1" constraint
sp {comprehend-word*East-constraint*self-m-name*ASSIGN*east1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a East
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |east1| })
-->
   (<l-slot1> ^name <target> -
              ^name |east1|)
}

#   EAST construction
sp {comprehend-word*apply*lexical-access*EAST-east
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |east|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name EAST
          ^is <a>
          ^orth |east|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of East
          ^first-lex nil)
   (<a> ^a EAST)
}

#   E construction
sp {comprehend-word*apply*lexical-access*E-e
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |e|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name E
          ^is <a>
          ^orth |e|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of East
          ^first-lex nil)
   (<a> ^a E)
}

#   West construction
sp {comprehend-word*generalize-cxn*West*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of West
          ^is <a>
          ^m <meaning>)
   (<a> -^a West)
-->
   (<a> ^a West)
   (<cxn> ^subcase-of West -
          ^subcase-of Direction
          ^evokes <e-meaning>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   West self.m.class <-- @cardinal-direction1 constraint
sp {comprehend-word*West-constraint*self-m-class*ASSIGN*AT-cardinal-direction1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a West
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |cardinal-direction1| })
-->
   (<l-slot1> ^class <target> -
              ^class |cardinal-direction1|)
}

#   West self.m.name <-- "west1" constraint
sp {comprehend-word*West-constraint*self-m-name*ASSIGN*west1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a West
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |west1| })
-->
   (<l-slot1> ^name <target> -
              ^name |west1|)
}

#   WEST construction
sp {comprehend-word*apply*lexical-access*WEST-west
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |west|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name WEST
          ^is <a>
          ^orth |west|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of West
          ^first-lex nil)
   (<a> ^a WEST)
}

#   W construction
sp {comprehend-word*apply*lexical-access*W-w
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |w|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name W
          ^is <a>
          ^orth |w|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of West
          ^first-lex nil)
   (<a> ^a W)
}

#   Done construction
sp {comprehend-word*generalize-cxn*Done*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of Done
          ^is <a>
          ^m <meaning>)
   (<a> -^a Done)
-->
   (<a> ^a Done)
   (<cxn> ^subcase-of Done -
          ^subcase-of Property
          ^evokes <e-meaning>)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   Done self.m.class <-- @state constraint
sp {comprehend-word*Done-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Done
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   Done self.m.name <-- "task-completed" constraint
sp {comprehend-word*Done-constraint*self-m-name*ASSIGN*task-completed
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Done
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |task-completed| })
-->
   (<l-slot1> ^name <target> -
              ^name |task-completed|)
}

#   DONE construction
sp {comprehend-word*apply*lexical-access*DONE-done
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |done|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name DONE
          ^is <a>
          ^orth |done|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Done
          ^first-lex nil)
   (<a> ^a DONE)
}

#   FINISHED construction
sp {comprehend-word*apply*lexical-access*FINISHED-finished
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |finished|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name FINISHED
          ^is <a>
          ^orth |finished|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Done
          ^first-lex nil)
   (<a> ^a FINISHED)
}

#   OVER construction
sp {comprehend-word*apply*lexical-access*OVER-over
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |over|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name OVER
          ^is <a>
          ^orth |over|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Done
          ^first-lex nil)
   (<a> ^a OVER)
}

#   VISIBLE construction
sp {comprehend-word*apply*lexical-access*VISIBLE-visible
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |visible|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name VISIBLE
          ^is <a>
          ^orth |visible|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a VISIBLE)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   VISIBLE self.m.class <-- @state constraint
sp {comprehend-word*VISIBLE-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a VISIBLE
          ^orth |visible|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   VISIBLE self.m.name <-- "visible" constraint
sp {comprehend-word*VISIBLE-constraint*self-m-name*ASSIGN*visible
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a VISIBLE
          ^orth |visible|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |visible| })
-->
   (<l-slot1> ^name <target> -
              ^name |visible|)
}

#   CURRENT construction
sp {comprehend-word*apply*lexical-access*CURRENT-current
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |current|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name CURRENT
          ^is <a>
          ^orth |current|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a CURRENT)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   CURRENT self.m.class <-- @state constraint
sp {comprehend-word*CURRENT-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CURRENT
          ^orth |current|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   CURRENT self.m.name <-- "current1" constraint
sp {comprehend-word*CURRENT-constraint*self-m-name*ASSIGN*current1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CURRENT
          ^orth |current|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |current1| })
-->
   (<l-slot1> ^name <target> -
              ^name |current1|)
}

#   STARTING construction
sp {comprehend-word*apply*lexical-access*STARTING-starting
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |starting|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name STARTING
          ^is <a>
          ^orth |starting|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a STARTING)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   STARTING self.m.class <-- @state constraint
sp {comprehend-word*STARTING-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a STARTING
          ^orth |starting|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   STARTING self.m.name <-- "starting1" constraint
sp {comprehend-word*STARTING-constraint*self-m-name*ASSIGN*starting1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a STARTING
          ^orth |starting|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |starting1| })
-->
   (<l-slot1> ^name <target> -
              ^name |starting1|)
}

#   EMPTY construction
sp {comprehend-word*apply*lexical-access*EMPTY-empty
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |empty|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name EMPTY
          ^is <a>
          ^orth |empty|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a EMPTY)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   EMPTY self.m.class <-- @state constraint
sp {comprehend-word*EMPTY-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a EMPTY
          ^orth |empty|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   EMPTY self.m.name <-- "empty" constraint
sp {comprehend-word*EMPTY-constraint*self-m-name*ASSIGN*empty
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a EMPTY
          ^orth |empty|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |empty| })
-->
   (<l-slot1> ^name <target> -
              ^name |empty|)
}

#   LIT construction
sp {comprehend-word*apply*lexical-access*LIT-lit
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |lit|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name LIT
          ^is <a>
          ^orth |lit|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a LIT)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   LIT self.m.class <-- @state constraint
sp {comprehend-word*LIT-constraint*self-m-class*ASSIGN*AT-state
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a LIT
          ^orth |lit|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |state| })
-->
   (<l-slot1> ^class <target> -
              ^class |state|)
}

#   LIT self.m.name <-- "on2" constraint
sp {comprehend-word*LIT-constraint*self-m-name*ASSIGN*on2
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a LIT
          ^orth |lit|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |on2| })
-->
   (<l-slot1> ^name <target> -
              ^name |on2|)
}

#   MAIN construction
sp {comprehend-word*apply*lexical-access*MAIN-main
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |main|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name MAIN
          ^is <a>
          ^orth |main|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a MAIN)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   MAIN self.m.class <-- @name constraint
sp {comprehend-word*MAIN-constraint*self-m-class*ASSIGN*AT-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MAIN
          ^orth |main|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |name| })
-->
   (<l-slot1> ^class <target> -
              ^class |name|)
}

#   MAIN self.m.name <-- "main1" constraint
sp {comprehend-word*MAIN-constraint*self-m-name*ASSIGN*main1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a MAIN
          ^orth |main|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |main1| })
-->
   (<l-slot1> ^name <target> -
              ^name |main1|)
}

#   SOAR construction
sp {comprehend-word*apply*lexical-access*SOAR-soar
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |soar|
           ^content <content1>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SOAR
          ^is <a>
          ^orth |soar|
          ^text <content1>
          ^f <form>
          ^m <meaning>
          ^subcase-of Property
          ^first-lex nil
          ^evokes <e-meaning>)
   (<a> ^a SOAR)
   (<e-meaning> ^schema PropertyDescriptor
                ^target <meaning>)
}

#   SOAR self.m.class <-- @name constraint
sp {comprehend-word*SOAR-constraint*self-m-class*ASSIGN*AT-name
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SOAR
          ^orth |soar|
          ^m <l-slot1>)
   (<l-slot1> ^class { <target> <> |name| })
-->
   (<l-slot1> ^class <target> -
              ^class |name|)
}

#   SOAR self.m.name <-- "soar1" constraint
sp {comprehend-word*SOAR-constraint*self-m-name*ASSIGN*soar1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SOAR
          ^orth |soar|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |soar1| })
-->
   (<l-slot1> ^name <target> -
              ^name |soar1|)
}

